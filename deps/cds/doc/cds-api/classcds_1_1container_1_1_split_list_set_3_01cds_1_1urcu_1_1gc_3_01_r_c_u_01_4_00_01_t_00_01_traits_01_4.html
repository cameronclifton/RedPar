<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__set.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Split-ordered list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/split_list_set_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.png" usemap="#cds::container::SplitListSet_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::SplitListSet_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20T_2C_20Traits_20_3E_map" name="cds::container::SplitListSet_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20T_2C_20Traits_20_3E_map">
<area href="classcds_1_1intrusive_1_1_split_list_set.html" alt="cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits::ordered_list, Traits &gt;" shape="rect" coords="0,0,467,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a830321fce2b3f841d3e3e5924465a9df"><td class="memItemLeft" align="right" valign="top"><a id="a830321fce2b3f841d3e3e5924465a9df"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a830321fce2b3f841d3e3e5924465a9df">gc</a></td></tr>
<tr class="memdesc:a830321fce2b3f841d3e3e5924465a9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU-based garbage collector. <br /></td></tr>
<tr class="separator:a830321fce2b3f841d3e3e5924465a9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee3f6a13d5a1aa7b59cf26977fa4a3"><td class="memItemLeft" align="right" valign="top"><a id="a70ee3f6a13d5a1aa7b59cf26977fa4a3"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a></td></tr>
<tr class="memdesc:a70ee3f6a13d5a1aa7b59cf26977fa4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of value to be storedin the set. <br /></td></tr>
<tr class="separator:a70ee3f6a13d5a1aa7b59cf26977fa4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc052ec20d2539d17bebb57ada830acf"><td class="memItemLeft" align="right" valign="top"><a id="afc052ec20d2539d17bebb57ada830acf"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#afc052ec20d2539d17bebb57ada830acf">traits</a></td></tr>
<tr class="memdesc:afc052ec20d2539d17bebb57ada830acf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Traits</code> template argument <br /></td></tr>
<tr class="separator:afc052ec20d2539d17bebb57ada830acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b33e3abb85421185d307ebbbdd1c78"><td class="memItemLeft" align="right" valign="top"><a id="a74b33e3abb85421185d307ebbbdd1c78"></a>
typedef maker::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a74b33e3abb85421185d307ebbbdd1c78">ordered_list</a></td></tr>
<tr class="memdesc:a74b33e3abb85421185d307ebbbdd1c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br /></td></tr>
<tr class="separator:a74b33e3abb85421185d307ebbbdd1c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81db4384b05b8e025bb11a2b9885e1df"><td class="memItemLeft" align="right" valign="top"><a id="a81db4384b05b8e025bb11a2b9885e1df"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a81db4384b05b8e025bb11a2b9885e1df">key_comparator</a></td></tr>
<tr class="memdesc:a81db4384b05b8e025bb11a2b9885e1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br /></td></tr>
<tr class="separator:a81db4384b05b8e025bb11a2b9885e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82af9b8890322b2afc85194c14d8ba74"><td class="memItemLeft" align="right" valign="top"><a id="a82af9b8890322b2afc85194c14d8ba74"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a82af9b8890322b2afc85194c14d8ba74">hash</a></td></tr>
<tr class="memdesc:a82af9b8890322b2afc85194c14d8ba74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:a82af9b8890322b2afc85194c14d8ba74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535b717d0a578311b8afb5f3e6f1d7f0"><td class="memItemLeft" align="right" valign="top"><a id="a535b717d0a578311b8afb5f3e6f1d7f0"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a535b717d0a578311b8afb5f3e6f1d7f0">item_counter</a></td></tr>
<tr class="memdesc:a535b717d0a578311b8afb5f3e6f1d7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a535b717d0a578311b8afb5f3e6f1d7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd05166a386907b79f3eb9896bdb786"><td class="memItemLeft" align="right" valign="top"><a id="a7fd05166a386907b79f3eb9896bdb786"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7fd05166a386907b79f3eb9896bdb786">stat</a></td></tr>
<tr class="memdesc:a7fd05166a386907b79f3eb9896bdb786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a7fd05166a386907b79f3eb9896bdb786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c2fef9f313fb096ae1745b4be103da"><td class="memItemLeft" align="right" valign="top">typedef base_class::rcu_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a79c2fef9f313fb096ae1745b4be103da">rcu_lock</a></td></tr>
<tr class="separator:a79c2fef9f313fb096ae1745b4be103da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0fafed34cc602948088754cc91c9d2"><td class="memItemLeft" align="right" valign="top"><a id="aff0fafed34cc602948088754cc91c9d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aff0fafed34cc602948088754cc91c9d2">exempt_ptr</a> = <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a830321fce2b3f841d3e3e5924465a9df">gc</a>, node_type, <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>, typename <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa4cfc2f23920086d62cef263e4b4f879">maker::ordered_list_traits::disposer</a> &gt;</td></tr>
<tr class="memdesc:aff0fafed34cc602948088754cc91c9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to extracted node <br /></td></tr>
<tr class="separator:aff0fafed34cc602948088754cc91c9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed04980c6c420658f8e540f92cee648"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1ed04980c6c420658f8e540f92cee648">raw_ptr</a></td></tr>
<tr class="memdesc:a1ed04980c6c420658f8e540f92cee648"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the node for <code><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a22a4e5e7b13f8a1d4cde1a020c1cd8f6" title="Finds the key key and return the item found. ">get()</a></code> function  <a href="#a1ed04980c6c420658f8e540f92cee648">More...</a><br /></td></tr>
<tr class="separator:a1ed04980c6c420658f8e540f92cee648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa10261c1a5f803f9542dee47988ca16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaa10261c1a5f803f9542dee47988ca16">SplitListSet</a> ()</td></tr>
<tr class="memdesc:aaa10261c1a5f803f9542dee47988ca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list of default capacity.  <a href="#aaa10261c1a5f803f9542dee47988ca16">More...</a><br /></td></tr>
<tr class="separator:aaa10261c1a5f803f9542dee47988ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae45b7ca0c41055ef152d51c0de0519"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2ae45b7ca0c41055ef152d51c0de0519">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a2ae45b7ca0c41055ef152d51c0de0519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list.  <a href="#a2ae45b7ca0c41055ef152d51c0de0519">More...</a><br /></td></tr>
<tr class="separator:a2ae45b7ca0c41055ef152d51c0de0519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5426434330a53312429d8d721fb66cc7"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5426434330a53312429d8d721fb66cc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5426434330a53312429d8d721fb66cc7">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a5426434330a53312429d8d721fb66cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5426434330a53312429d8d721fb66cc7">More...</a><br /></td></tr>
<tr class="separator:a5426434330a53312429d8d721fb66cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce3889ba7c9516fe71cca9f03c0e01b"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:adce3889ba7c9516fe71cca9f03c0e01b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#adce3889ba7c9516fe71cca9f03c0e01b">insert</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:adce3889ba7c9516fe71cca9f03c0e01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#adce3889ba7c9516fe71cca9f03c0e01b">More...</a><br /></td></tr>
<tr class="separator:adce3889ba7c9516fe71cca9f03c0e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419e3cc109a863c15fb8c0ce70a235a0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a419e3cc109a863c15fb8c0ce70a235a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a419e3cc109a863c15fb8c0ce70a235a0">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a419e3cc109a863c15fb8c0ce70a235a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> created from <code>args</code>.  <a href="#a419e3cc109a863c15fb8c0ce70a235a0">More...</a><br /></td></tr>
<tr class="separator:a419e3cc109a863c15fb8c0ce70a235a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52416cc3418f86798d46512c526b075"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aa52416cc3418f86798d46512c526b075"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aa52416cc3418f86798d46512c526b075">update</a> (Q const &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:aa52416cc3418f86798d46512c526b075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an element with given <code>val</code>.  <a href="#aa52416cc3418f86798d46512c526b075">More...</a><br /></td></tr>
<tr class="separator:aa52416cc3418f86798d46512c526b075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9d2591d87d680e1e0942e28a636e8"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac2d9d2591d87d680e1e0942e28a636e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac2d9d2591d87d680e1e0942e28a636e8">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ac2d9d2591d87d680e1e0942e28a636e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#ac2d9d2591d87d680e1e0942e28a636e8">More...</a><br /></td></tr>
<tr class="separator:ac2d9d2591d87d680e1e0942e28a636e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0813e79767faec8708232805e1e63e8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ac0813e79767faec8708232805e1e63e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac0813e79767faec8708232805e1e63e8">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ac0813e79767faec8708232805e1e63e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ac0813e79767faec8708232805e1e63e8">More...</a><br /></td></tr>
<tr class="separator:ac0813e79767faec8708232805e1e63e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a0a2ad7d9963027c9f44c7a9e4bd7a2ae">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#a0a2ad7d9963027c9f44c7a9e4bd7a2ae">More...</a><br /></td></tr>
<tr class="separator:a0a2ad7d9963027c9f44c7a9e4bd7a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e77899f2784acde39124d511b47c53"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ad8e77899f2784acde39124d511b47c53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad8e77899f2784acde39124d511b47c53">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ad8e77899f2784acde39124d511b47c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ad8e77899f2784acde39124d511b47c53">More...</a><br /></td></tr>
<tr class="separator:ad8e77899f2784acde39124d511b47c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5a6c6c638569b385ff29083a6e82a4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ada5a6c6c638569b385ff29083a6e82a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aff0fafed34cc602948088754cc91c9d2">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ada5a6c6c638569b385ff29083a6e82a4">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ada5a6c6c638569b385ff29083a6e82a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set.  <a href="#ada5a6c6c638569b385ff29083a6e82a4">More...</a><br /></td></tr>
<tr class="separator:ada5a6c6c638569b385ff29083a6e82a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e14835406eb6b8a008a6ddc75d08a0d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a5e14835406eb6b8a008a6ddc75d08a0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aff0fafed34cc602948088754cc91c9d2">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5e14835406eb6b8a008a6ddc75d08a0d">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5e14835406eb6b8a008a6ddc75d08a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set using <code>pred</code> predicate for searching.  <a href="#a5e14835406eb6b8a008a6ddc75d08a0d">More...</a><br /></td></tr>
<tr class="separator:a5e14835406eb6b8a008a6ddc75d08a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5dc83748a948c863c9e960e7ccf520"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a5c5dc83748a948c863c9e960e7ccf520"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5c5dc83748a948c863c9e960e7ccf520">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a5c5dc83748a948c863c9e960e7ccf520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a5c5dc83748a948c863c9e960e7ccf520">More...</a><br /></td></tr>
<tr class="separator:a5c5dc83748a948c863c9e960e7ccf520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf61a70a84aa1116d913897217d195ec"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aaf61a70a84aa1116d913897217d195ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aaf61a70a84aa1116d913897217d195ec">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aaf61a70a84aa1116d913897217d195ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aaf61a70a84aa1116d913897217d195ec">More...</a><br /></td></tr>
<tr class="separator:aaf61a70a84aa1116d913897217d195ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada63998413c24d1b18a6b8c79ee6ebc1"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ada63998413c24d1b18a6b8c79ee6ebc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ada63998413c24d1b18a6b8c79ee6ebc1">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ada63998413c24d1b18a6b8c79ee6ebc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#ada63998413c24d1b18a6b8c79ee6ebc1">More...</a><br /></td></tr>
<tr class="separator:ada63998413c24d1b18a6b8c79ee6ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae929db1391b45c46e073e6caa2f8a4bd"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ae929db1391b45c46e073e6caa2f8a4bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae929db1391b45c46e073e6caa2f8a4bd">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ae929db1391b45c46e073e6caa2f8a4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#ae929db1391b45c46e073e6caa2f8a4bd">More...</a><br /></td></tr>
<tr class="separator:ae929db1391b45c46e073e6caa2f8a4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4e5e7b13f8a1d4cde1a020c1cd8f6"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a22a4e5e7b13f8a1d4cde1a020c1cd8f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1ed04980c6c420658f8e540f92cee648">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a22a4e5e7b13f8a1d4cde1a020c1cd8f6">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a22a4e5e7b13f8a1d4cde1a020c1cd8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a22a4e5e7b13f8a1d4cde1a020c1cd8f6">More...</a><br /></td></tr>
<tr class="separator:a22a4e5e7b13f8a1d4cde1a020c1cd8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df123766832f05e9a7a07cda98379d3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a2df123766832f05e9a7a07cda98379d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1ed04980c6c420658f8e540f92cee648">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2df123766832f05e9a7a07cda98379d3">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a2df123766832f05e9a7a07cda98379d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a2df123766832f05e9a7a07cda98379d3">More...</a><br /></td></tr>
<tr class="separator:a2df123766832f05e9a7a07cda98379d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158e36626a98950dfa704e56350f8c7a"><td class="memItemLeft" align="right" valign="top"><a id="a158e36626a98950dfa704e56350f8c7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a158e36626a98950dfa704e56350f8c7a">clear</a> ()</td></tr>
<tr class="memdesc:a158e36626a98950dfa704e56350f8c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic) <br /></td></tr>
<tr class="separator:a158e36626a98950dfa704e56350f8c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932ef09bac6c32bef0f5888e9a67d2cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a932ef09bac6c32bef0f5888e9a67d2cd">empty</a> () const</td></tr>
<tr class="memdesc:a932ef09bac6c32bef0f5888e9a67d2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a932ef09bac6c32bef0f5888e9a67d2cd">More...</a><br /></td></tr>
<tr class="separator:a932ef09bac6c32bef0f5888e9a67d2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f7d94b054437d42f713ac9f944d41"><td class="memItemLeft" align="right" valign="top"><a id="afe7f7d94b054437d42f713ac9f944d41"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#afe7f7d94b054437d42f713ac9f944d41">size</a> () const</td></tr>
<tr class="memdesc:afe7f7d94b054437d42f713ac9f944d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:afe7f7d94b054437d42f713ac9f944d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84181db7b9c0e722e17fd3e2dd03dc8"><td class="memItemLeft" align="right" valign="top"><a id="ab84181db7b9c0e722e17fd3e2dd03dc8"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7fd05166a386907b79f3eb9896bdb786">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab84181db7b9c0e722e17fd3e2dd03dc8">statistics</a> () const</td></tr>
<tr class="memdesc:ab84181db7b9c0e722e17fd3e2dd03dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:ab84181db7b9c0e722e17fd3e2dd03dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48bb97c807f117dada24609e8400e7f"><td class="memItemLeft" align="right" valign="top"><a id="ae48bb97c807f117dada24609e8400e7f"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad39196ac90597908219c5b130b37f47c">ordered_list::stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae48bb97c807f117dada24609e8400e7f">list_statistics</a> () const</td></tr>
<tr class="memdesc:ae48bb97c807f117dada24609e8400e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics for <code>ordered_list</code>. <br /></td></tr>
<tr class="separator:ae48bb97c807f117dada24609e8400e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af7f73df8932b5489ef2530a9f160d6ea"><td class="memItemLeft" align="right" valign="top"><a id="af7f73df8932b5489ef2530a9f160d6ea"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af7f73df8932b5489ef2530a9f160d6ea">c_bExtractLockExternal</a> = base_class::c_bExtractLockExternal</td></tr>
<tr class="memdesc:af7f73df8932b5489ef2530a9f160d6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions require external locking if underlying ordered list requires that. <br /></td></tr>
<tr class="separator:af7f73df8932b5489ef2530a9f160d6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Forward iterators (thread-safe under RCU lock)</h2></td></tr>
<tr class="memitem:a5f2c87cc75df17ac89786d9b7fc6c432"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a></td></tr>
<tr class="memdesc:a5f2c87cc75df17ac89786d9b7fc6c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#a5f2c87cc75df17ac89786d9b7fc6c432">More...</a><br /></td></tr>
<tr class="separator:a5f2c87cc75df17ac89786d9b7fc6c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9af7fdce306b796a7e3cd49cdea120"><td class="memItemLeft" align="right" valign="top"><a id="a9f9af7fdce306b796a7e3cd49cdea120"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a></td></tr>
<tr class="memdesc:a9f9af7fdce306b796a7e3cd49cdea120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward const iterator. <br /></td></tr>
<tr class="separator:a9f9af7fdce306b796a7e3cd49cdea120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b749193c0afb53019a23e55d056e30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5b749193c0afb53019a23e55d056e30d">begin</a> ()</td></tr>
<tr class="memdesc:a5b749193c0afb53019a23e55d056e30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set.  <a href="#a5b749193c0afb53019a23e55d056e30d">More...</a><br /></td></tr>
<tr class="separator:a5b749193c0afb53019a23e55d056e30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730086ffb1a533f013ca86bd43d1d719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719">end</a> ()</td></tr>
<tr class="memdesc:a730086ffb1a533f013ca86bd43d1d719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a set.  <a href="#a730086ffb1a533f013ca86bd43d1d719">More...</a><br /></td></tr>
<tr class="separator:a730086ffb1a533f013ca86bd43d1d719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae804db335ab64c6b84e778e26c4ed75f"><td class="memItemLeft" align="right" valign="top"><a id="ae804db335ab64c6b84e778e26c4ed75f"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae804db335ab64c6b84e778e26c4ed75f">begin</a> () const</td></tr>
<tr class="memdesc:ae804db335ab64c6b84e778e26c4ed75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ae804db335ab64c6b84e778e26c4ed75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ff3898468fc3afa83ff8853e5bec7"><td class="memItemLeft" align="right" valign="top"><a id="aa76ff3898468fc3afa83ff8853e5bec7"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aa76ff3898468fc3afa83ff8853e5bec7">cbegin</a> () const</td></tr>
<tr class="memdesc:aa76ff3898468fc3afa83ff8853e5bec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:aa76ff3898468fc3afa83ff8853e5bec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5f5fb07768c5ed9a3eefe1525fd892"><td class="memItemLeft" align="right" valign="top"><a id="a9f5f5fb07768c5ed9a3eefe1525fd892"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f5f5fb07768c5ed9a3eefe1525fd892">end</a> () const</td></tr>
<tr class="memdesc:a9f5f5fb07768c5ed9a3eefe1525fd892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a9f5f5fb07768c5ed9a3eefe1525fd892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d1183b1ddccf33c0cf0e2b276bd87e"><td class="memItemLeft" align="right" valign="top"><a id="a87d1183b1ddccf33c0cf0e2b276bd87e"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87d1183b1ddccf33c0cf0e2b276bd87e">cend</a> () const</td></tr>
<tr class="memdesc:a87d1183b1ddccf33c0cf0e2b276bd87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a87d1183b1ddccf33c0cf0e2b276bd87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits::ordered_list, Traits &gt;</a></td></tr>
<tr class="memitem:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aea2de69bd86f37bd184ca50d50e29f0e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aea2de69bd86f37bd184ca50d50e29f0e">gc</a></td></tr>
<tr class="memdesc:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab8244c115c0dd6b116c9edb9a456c2ee"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab8244c115c0dd6b116c9edb9a456c2ee">traits</a></td></tr>
<tr class="memdesc:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br /></td></tr>
<tr class="separator:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a719263aaf48921d5ced55707389f961a"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a></td></tr>
<tr class="memdesc:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list used as a base for split-list <br /></td></tr>
<tr class="separator:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="afae9f358f06403565d75e8a6666e0f8f"></a>
typedef ordered_list::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a></td></tr>
<tr class="memdesc:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the split-list <br /></td></tr>
<tr class="separator:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac4ac7447e2749a53db596bef99378f0a"></a>
typedef ordered_list::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac4ac7447e2749a53db596bef99378f0a">key_comparator</a></td></tr>
<tr class="memdesc:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa4cfc2f23920086d62cef263e4b4f879"></a>
typedef ordered_list::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa4cfc2f23920086d62cef263e4b4f879">disposer</a></td></tr>
<tr class="memdesc:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node disposer functor. <br /></td></tr>
<tr class="separator:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="af1255a3a554c960d60f7c07d8c0d71b9"></a>
typedef cds::opt::v::hash_selector&lt; typename traits::hash &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#af1255a3a554c960d60f7c07d8c0d71b9">hash</a></td></tr>
<tr class="memdesc:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives you use. <br /></td></tr>
<tr class="separator:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add53037afc9b91c6b3ba75d776a135d4 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="add53037afc9b91c6b3ba75d776a135d4"></a>
typedef traits::bit_reversal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#add53037afc9b91c6b3ba75d776a135d4">bit_reversal</a></td></tr>
<tr class="memdesc:add53037afc9b91c6b3ba75d776a135d4 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit reversal algorithm, see <code>split_list::traits::bit_reversal</code>. <br /></td></tr>
<tr class="separator:add53037afc9b91c6b3ba75d776a135d4 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa1562c4a7ce60945722157d589606eb0"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa1562c4a7ce60945722157d589606eb0">item_counter</a></td></tr>
<tr class="memdesc:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab69886a6028245b341ac8dfaaaf70a40"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab69886a6028245b341ac8dfaaaf70a40">back_off</a></td></tr>
<tr class="memdesc:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy for spinning <br /></td></tr>
<tr class="separator:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac781a58af799ac8bcfeb5027d1b03536"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac781a58af799ac8bcfeb5027d1b03536">memory_model</a></td></tr>
<tr class="memdesc:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a6b3b57584e1fd7f743b1ab806c138a72"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a></td></tr>
<tr class="memdesc:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics, see <code>spit_list::stat</code>. <br /></td></tr>
<tr class="separator:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a0933c1b9d510566c2538779f1ad81e14"></a>
typedef ordered_list::guarded_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a></td></tr>
<tr class="memdesc:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a></td></tr>
<tr class="memdesc:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">More...</a><br /></td></tr>
<tr class="separator:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a></td></tr>
<tr class="memdesc:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">More...</a><br /></td></tr>
<tr class="separator:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits::ordered_list, Traits &gt;</a></td></tr>
<tr class="memitem:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a685c56051b1ffc44511a5ec12b80b2d0">SplitListSet</a> ()</td></tr>
<tr class="memdesc:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list of default capacity.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a685c56051b1ffc44511a5ec12b80b2d0">More...</a><br /></td></tr>
<tr class="separator:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a56c73356d78265849a8cce93155480eb">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a56c73356d78265849a8cce93155480eb">More...</a><br /></td></tr>
<tr class="separator:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac107f9755fb5080b6c4cd03f3245bbbe inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac107f9755fb5080b6c4cd03f3245bbbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac107f9755fb5080b6c4cd03f3245bbbe">~SplitListSet</a> ()</td></tr>
<tr class="memdesc:ac107f9755fb5080b6c4cd03f3245bbbe inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys split-list set. <br /></td></tr>
<tr class="separator:ac107f9755fb5080b6c4cd03f3245bbbe inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a5fa996ee4f495c0a059c3bb031f7aa06">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a5fa996ee4f495c0a059c3bb031f7aa06">More...</a><br /></td></tr>
<tr class="separator:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a93fc790b0a2969b2795ddad438d4243a">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a93fc790b0a2969b2795ddad438d4243a">More...</a><br /></td></tr>
<tr class="separator:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac7ab1789e44fe8fec6bfb5bbc3a1d4c2">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#ac7ab1789e44fe8fec6bfb5bbc3a1d4c2">More...</a><br /></td></tr>
<tr class="separator:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ac55def7875486d4872cbd0c36d3d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a46ac55def7875486d4872cbd0c36d3d0">upsert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a46ac55def7875486d4872cbd0c36d3d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or updates the node (only for <code>IterableList</code>)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a46ac55def7875486d4872cbd0c36d3d0">More...</a><br /></td></tr>
<tr class="separator:a46ac55def7875486d4872cbd0c36d3d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">More...</a><br /></td></tr>
<tr class="separator:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a25ab99e28bc6bc1147c12ef0994e7c0e">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a25ab99e28bc6bc1147c12ef0994e7c0e">More...</a><br /></td></tr>
<tr class="separator:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae72b3c31a3fe7f78fc7795c5744848b0">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#ae72b3c31a3fe7f78fc7795c5744848b0">More...</a><br /></td></tr>
<tr class="separator:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a87a3128bc56d8278fcdfb1930d37fb98">erase_with</a> (const Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a87a3128bc56d8278fcdfb1930d37fb98">More...</a><br /></td></tr>
<tr class="separator:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b525b1f5b240a9c6036057bc0003fd8">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a6b525b1f5b240a9c6036057bc0003fd8">More...</a><br /></td></tr>
<tr class="separator:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2eca50286e31ce16e4d1e51306c1e3 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afd2eca50286e31ce16e4d1e51306c1e3">erase_at</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a> const &amp;iter)</td></tr>
<tr class="memdesc:afd2eca50286e31ce16e4d1e51306c1e3 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item pointed by iterator <code>iter</code> (only for <code>IterableList</code> based set)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#afd2eca50286e31ce16e4d1e51306c1e3">More...</a><br /></td></tr>
<tr class="separator:afd2eca50286e31ce16e4d1e51306c1e3 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4fc11d5658a648a54098ec1455b70578">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a4fc11d5658a648a54098ec1455b70578">More...</a><br /></td></tr>
<tr class="separator:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa2511f775b91f22e6372c361011eca3e">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#aa2511f775b91f22e6372c361011eca3e">More...</a><br /></td></tr>
<tr class="separator:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a14087851b392163b5c6317c4c7fcfc54">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a14087851b392163b5c6317c4c7fcfc54">More...</a><br /></td></tr>
<tr class="separator:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d12f67fb5b9f880037f58aac58f7d16 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2d12f67fb5b9f880037f58aac58f7d16">find</a> (Q &amp;key)</td></tr>
<tr class="memdesc:a2d12f67fb5b9f880037f58aac58f7d16 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and returns iterator pointed to the item found (only for <code>IterableList</code>)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a2d12f67fb5b9f880037f58aac58f7d16">More...</a><br /></td></tr>
<tr class="separator:a2d12f67fb5b9f880037f58aac58f7d16 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#acfcb668b144364e7c2bab2f4dc0cc9e6">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#acfcb668b144364e7c2bab2f4dc0cc9e6">More...</a><br /></td></tr>
<tr class="separator:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8141589095b24499111ab2cf10e6b8a2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a8141589095b24499111ab2cf10e6b8a2">find_with</a> (Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a8141589095b24499111ab2cf10e6b8a2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate and returns iterator pointed to the item found (only for <code>IterableList</code>)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a8141589095b24499111ab2cf10e6b8a2">More...</a><br /></td></tr>
<tr class="separator:a8141589095b24499111ab2cf10e6b8a2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a9ce860bde9bcb5ef71f87a796387687e">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a9ce860bde9bcb5ef71f87a796387687e">More...</a><br /></td></tr>
<tr class="separator:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#adba7f5058868947b9b9ac189fd97e712">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#adba7f5058868947b9b9ac189fd97e712">More...</a><br /></td></tr>
<tr class="separator:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afe6e8ba28a58586de9e556b1c82069a5">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#afe6e8ba28a58586de9e556b1c82069a5">More...</a><br /></td></tr>
<tr class="separator:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0217cf552409c17f9d49689224812fb5">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a0217cf552409c17f9d49689224812fb5">More...</a><br /></td></tr>
<tr class="separator:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b445fac9e849bc2c8a584f414460749 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a0b445fac9e849bc2c8a584f414460749"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0b445fac9e849bc2c8a584f414460749">size</a> () const</td></tr>
<tr class="memdesc:a0b445fac9e849bc2c8a584f414460749 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a0b445fac9e849bc2c8a584f414460749 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49303695660aa5da4f07971bc22f8230 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a49303695660aa5da4f07971bc22f8230">empty</a> () const</td></tr>
<tr class="memdesc:a49303695660aa5da4f07971bc22f8230 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a49303695660aa5da4f07971bc22f8230">More...</a><br /></td></tr>
<tr class="separator:a49303695660aa5da4f07971bc22f8230 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0f3fc77a7939fd3553a594fc5a315572">clear</a> ()</td></tr>
<tr class="memdesc:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a0f3fc77a7939fd3553a594fc5a315572">More...</a><br /></td></tr>
<tr class="separator:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c9eec1fc9886e87391ec042d567f43 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a47c9eec1fc9886e87391ec042d567f43"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a47c9eec1fc9886e87391ec042d567f43">statistics</a> () const</td></tr>
<tr class="memdesc:a47c9eec1fc9886e87391ec042d567f43 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:a47c9eec1fc9886e87391ec042d567f43 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9eee48751a4718bff046a19404b77 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aeec9eee48751a4718bff046a19404b77"></a>
T ::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aeec9eee48751a4718bff046a19404b77">list_statistics</a> () const</td></tr>
<tr class="memdesc:aeec9eee48751a4718bff046a19404b77 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics for <code>OrderedList</code>. <br /></td></tr>
<tr class="separator:aeec9eee48751a4718bff046a19404b77 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae9f775376add33a1d7d2b82463670a55">begin</a> ()</td></tr>
<tr class="memdesc:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a split-list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#ae9f775376add33a1d7d2b82463670a55">More...</a><br /></td></tr>
<tr class="separator:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca35336f221c112be2292cc0f85a5f9 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a7ca35336f221c112be2292cc0f85a5f9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a7ca35336f221c112be2292cc0f85a5f9">begin</a> () const</td></tr>
<tr class="memdesc:a7ca35336f221c112be2292cc0f85a5f9 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:a7ca35336f221c112be2292cc0f85a5f9 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4f5c1a7fb52b15cea10bbaa04c926517">end</a> ()</td></tr>
<tr class="memdesc:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a split-list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a4f5c1a7fb52b15cea10bbaa04c926517">More...</a><br /></td></tr>
<tr class="separator:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78e5d2e78aa2f53eece612ed47d4e51 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab78e5d2e78aa2f53eece612ed47d4e51"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab78e5d2e78aa2f53eece612ed47d4e51">end</a> () const</td></tr>
<tr class="memdesc:ab78e5d2e78aa2f53eece612ed47d4e51 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:ab78e5d2e78aa2f53eece612ed47d4e51 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964f67e0f108826c03b1cef0b30aa2e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa964f67e0f108826c03b1cef0b30aa2e"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa964f67e0f108826c03b1cef0b30aa2e">cbegin</a> () const</td></tr>
<tr class="memdesc:aa964f67e0f108826c03b1cef0b30aa2e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:aa964f67e0f108826c03b1cef0b30aa2e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18634ad0407319550ce70512d9993d86 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a18634ad0407319550ce70512d9993d86"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a18634ad0407319550ce70512d9993d86">cend</a> () const</td></tr>
<tr class="memdesc:a18634ad0407319550ce70512d9993d86 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:a18634ad0407319550ce70512d9993d86 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits::ordered_list, Traits &gt;</a></td></tr>
<tr class="memitem:a85e623d9bfc5b586f0d00aa38d1ae011 inherit pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a85e623d9bfc5b586f0d00aa38d1ae011"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a85e623d9bfc5b586f0d00aa38d1ae011">c_nHazardPtrCount</a></td></tr>
<tr class="memdesc:a85e623d9bfc5b586f0d00aa38d1ae011 inherit pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required. <br /></td></tr>
<tr class="separator:a85e623d9bfc5b586f0d00aa38d1ae011 inherit pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, class T, class Traits = split_list::traits&gt;<br />
class cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</h3>

<p>Split-ordered list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu"></a> Hash table implementation based on split-ordered list algorithm discovered by Ori Shalev and Nir Shavit, see</p><ul>
<li>[2003] Ori Shalev, Nir Shavit "Split-Ordered Lists - Lock-free Resizable Hash Tables"</li>
<li>[2008] Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>See <code><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html" title="Split-ordered list. ">intrusive::SplitListSet</a></code> for a brief description of the split-list algorithm.</p>
<p>Template parameters:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>T</code> - type of the value to be stored in the split-list.</li>
<li><code>Traits</code> - type traits, default is <code><a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits ">split_list::traits</a></code>. Instead of declaring <code><a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits ">split_list::traits</a></code> -based struct you can apply option-based notation with <code><a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct. ">split_list::make_traits</a></code> metafunction.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> and <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9f9af7fdce306b796a7e3cd49cdea120">const_iterator</a>). The iteration is unordered.</p>
<p>You may iterate over split-list set items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any set's item cannot be reclaimed.</p>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads</dd>
<dd>
Due to concurrent nature of skip-list set it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the set, and your iteration can be terminated before end of the set. Therefore, such iteration is more suitable for debugging purposes</dd></dl>
<p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> {</div><div class="line">    <span class="comment">// Default ctor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy ctor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; s);</div><div class="line"></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Pre-increment</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Copy assignment</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&amp; src);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> Note, the iterator object returned by <code><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719" title="Returns an iterator that addresses the location succeeding the last element in a set. ">end()</a></code>, <code><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a87d1183b1ddccf33c0cf0e2b276bd87e" title="Returns an const iterator that addresses the location succeeding the last element in a set...">cend()</a></code> member functions points to <code>nullptr</code> and should not be dereferenced.</p>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
<p>You should decide what garbage collector you want, and what ordered list you want to use. Split-ordered list is an original data structure based on an ordered list. Suppose, you want construct split-list set based on <code>cds::urcu::general_buffered&lt;&gt;</code> GC and <code><a class="el" href="classcds_1_1container_1_1_lazy_list.html" title="Lazy ordered list. ">LazyList</a></code> as ordered list implementation. So, you beginning your program with following include: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/lazy_list_rcu.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/split_list_set_rcu.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>cc = <a class="code" href="namespacecds_1_1container.html">cds::container</a>;</div><div class="line"></div><div class="line"><span class="comment">// The data belonged to split-ordered list</span></div><div class="line">sturuct foo {</div><div class="line">    <span class="keywordtype">int</span>     nKey;   <span class="comment">// key field</span></div><div class="line">    std::string strValue    ;   <span class="comment">// value field</span></div><div class="line">};</div></div><!-- fragment --><p> The inclusion order is important:</p><ul>
<li>first, include one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU implementation</a> (<code>cds/urcu/general_buffered.h</code> in our case)</li>
<li>second, include file for ordered-list implementation (for this example, <code>cds/container/lazy_list_rcu.h</code>),</li>
<li>then, the header for RCU-based split-list set <code>cds/container/split_list_set_rcu.h</code>.</li>
</ul>
<p>Now, you should declare traits for split-list set. The main parts of traits are a hash functor for the set and a comparing functor for ordered list. Note that we define several function in <code>foo_hash</code> and <code>foo_less</code> functors for different argument types since we want call our <code>SplitListSet</code> object by the key of type <code>int</code> and by the value of type <code>foo</code>.</p>
<p>The second attention: instead of using <code>LazyList</code> in <code>SplitListSet</code> traits we use <code>cds::contaner::lazy_list_tag</code> tag for the lazy list. The split-list requires significant support from underlying ordered list class and it is not good idea to dive you into deep implementation details of split-list and ordered list interrelations. The tag paradigm simplifies split-list interface.</p>
<div class="fragment"><div class="line"><span class="comment">// foo hash functor</span></div><div class="line"><span class="keyword">struct </span>foo_hash {</div><div class="line">    <span class="keywordtype">size_t</span> operator()( <span class="keywordtype">int</span> key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html#aaa2ab388cbeccec46d1dc63e66ea5ec7">std::hash</a>( key ) ; }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( foo <span class="keyword">const</span>&amp; item )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html#aaa2ab388cbeccec46d1dc63e66ea5ec7">std::hash</a>( item.nKey ) ; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// foo comparator</span></div><div class="line"><span class="keyword">struct </span>foo_less {</div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> i, foo <span class="keyword">const</span>&amp; f )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> i &lt; f.nKey ; }</div><div class="line">    <span class="keywordtype">bool</span> operator()(foo <span class="keyword">const</span>&amp; f, <span class="keywordtype">int</span> i )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f.nKey &lt; i ; }</div><div class="line">    <span class="keywordtype">bool</span> operator()(foo <span class="keyword">const</span>&amp; f1, foo <span class="keyword">const</span>&amp; f2)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> f1.nKey &lt; f2.nKey; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// SplitListSet traits</span></div><div class="line"><span class="keyword">struct </span>foo_set_traits: <span class="keyword">public</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html#a5b05520aea1e3dab4ae7bb080df7c9d5">cc::split_list::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> cc::lazy_list_tag   <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a74b33e3abb85421185d307ebbbdd1c78">ordered_list</a>    ;   <span class="comment">// what type of ordered list we want to use</span></div><div class="line">    <span class="keyword">typedef</span> foo_hash            <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a82af9b8890322b2afc85194c14d8ba74">hash</a>            ;   <span class="comment">// hash functor for our data stored in split-list set</span></div><div class="line"></div><div class="line">    <span class="comment">// Type traits for our LazyList class</span></div><div class="line">    <span class="keyword">struct </span>ordered_list_traits: <span class="keyword">public</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html#a5b05520aea1e3dab4ae7bb080df7c9d5">cc::lazy_list::traits</a></div><div class="line">    {</div><div class="line">        <span class="keyword">typedef</span> foo_less less   ;   <span class="comment">// use our foo_less as comparator to order list nodes</span></div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Now you are ready to declare our set class based on <code>SplitListSet</code>: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cc::SplitListSet&lt; cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;, foo, foo_set_traits &gt; foo_set;</div></div><!-- fragment --><p>You may use the modern option-based declaration instead of classic type-traits-based one: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html#aa5670755719b66f046d52f43292a0611">cc::SplitListSet</a>&lt;</div><div class="line">    cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;   <span class="comment">// RCU type used</span></div><div class="line">    ,foo                                            <span class="comment">// type of data stored</span></div><div class="line">    ,cc::split_list::make_traits&lt;      <span class="comment">// metafunction to build split-list traits</span></div><div class="line">        cc::split_list::ordered_list&lt;cc::lazy_list_tag&gt;     <span class="comment">// tag for underlying ordered list implementation</span></div><div class="line">        ,cc::opt::hash&lt; foo_hash &gt;              <span class="comment">// hash functor</span></div><div class="line">        ,cc::split_list::ordered_list_traits&lt;   <span class="comment">// ordered list traits</span></div><div class="line">            cc::lazy_list::make_traits&lt;         <span class="comment">// metafunction to build lazy list traits</span></div><div class="line">                cc::opt::less&lt; foo_less &gt;       <span class="comment">// less-based compare functor</span></div><div class="line">            &gt;::type</div><div class="line">        &gt;</div><div class="line">    &gt;::type</div><div class="line">&gt;  foo_set;</div></div><!-- fragment --><p> In case of option-based declaration using <code><a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct. ">split_list::make_traits</a></code> metafunction the struct <code>foo_set_traits</code> is not required.</p>
<p>Now, the set of type <code>foo_set</code> is ready to use in your program.</p>
<p>Note that in this example we show only mandatory <code>traits</code> parts, optional ones is the default and they are inherited from <code><a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits ">container::split_list::traits</a></code>. There are many other options for deep tuning of the split-list and ordered-list containers. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5f2c87cc75df17ac89786d9b7fc6c432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2c87cc75df17ac89786d9b7fc6c432">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;false&gt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward iterator. </p>
<p>The forward iterator for Michael's set is based on <code>OrderedList</code> forward iterator and has some features:</p><ul>
<li>it has no post-increment operator</li>
<li>it iterates items in unordered fashion</li>
</ul>
<p>You may safely use iterators in multi-threaded environment only under RCU lock. Otherwise, a crash is possible if another thread deletes the element the iterator points to.</p>
<p>The iterator interface: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Default constructor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy construtor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; src );</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Preincrement operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Assignment operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a>&amp; operator = (<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; src);</div><div class="line"></div><div class="line">    <span class="comment">// Equality operators</span></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --> 
</div>
</div>
<a id="a1ed04980c6c420658f8e540f92cee648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed04980c6c420658f8e540f92cee648">&#9670;&nbsp;</a></span>raw_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1ed04980c6c420658f8e540f92cee648">raw_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to the node for <code><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a22a4e5e7b13f8a1d4cde1a020c1cd8f6" title="Finds the key key and return the item found. ">get()</a></code> function </p>
<p>For <code><a class="el" href="classcds_1_1container_1_1_lazy_list.html" title="Lazy ordered list. ">LazyList</a></code>, <code>raw_ptr</code> is just pointer to <code>value_type</code>.</p>
<p>For <code><a class="el" href="classcds_1_1container_1_1_michael_list.html" title="Michael&#39;s ordered list. ">MichaelList</a></code>, <code>raw_ptr</code> is <code><a class="el" href="classcds_1_1urcu_1_1raw__ptr.html" title="Raw pointer to node of RCU-based container. ">cds::urcu::raw_ptr</a></code> object giving access to <code>value_type</code>. </p>

</div>
</div>
<a id="a79c2fef9f313fb096ae1745b4be103da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c2fef9f313fb096ae1745b4be103da">&#9670;&nbsp;</a></span>rcu_lock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::rcu_lock <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a79c2fef9f313fb096ae1745b4be103da">rcu_lock</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RCU scoped lock </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa10261c1a5f803f9542dee47988ca16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa10261c1a5f803f9542dee47988ca16">&#9670;&nbsp;</a></span>SplitListSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set.html">SplitListSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered list of default capacity. </p>
<p>The default capacity is defined in bucket table constructor. See <code><a class="el" href="classcds_1_1intrusive_1_1split__list_1_1expandable__bucket__table.html" title="Expandable bucket table. ">intrusive::split_list::expandable_bucket_table</a></code>, <code><a class="el" href="classcds_1_1intrusive_1_1split__list_1_1static__bucket__table.html" title="Static bucket table. ">intrusive::split_list::static_bucket_table</a></code> which selects by <code><a class="el" href="namespacecds_1_1container_1_1split__list.html#ad43684b671934bab89303c17d9af9981" title="Selector of bucket table implementation = typedef for intrusive::split_list::dynamic_bucket_table. ">container::split_list::dynamic_bucket_table</a></code> option. </p>

</div>
</div>
<a id="a2ae45b7ca0c41055ef152d51c0de0519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae45b7ca0c41055ef152d51c0de0519">&#9670;&nbsp;</a></span>SplitListSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_set.html">SplitListSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nItemCount</td><td>estimated average of item count </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor - average item count per bucket. Small integer up to 8, default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5b749193c0afb53019a23e55d056e30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b749193c0afb53019a23e55d056e30d">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a set. </p>
<p>For empty set</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5b749193c0afb53019a23e55d056e30d">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="ada63998413c24d1b18a6b8c79ee6ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada63998413c24d1b18a6b8c79ee6ebc1">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. Otherwise, you may use <code><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae929db1391b45c46e073e6caa2f8a4bd" title="Checks whether the map contains key using pred predicate for searching. ">contains( Q const&amp;, Less pred )</a></code> functions with explicit predicate for key comparing.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a id="ae929db1391b45c46e073e6caa2f8a4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae929db1391b45c46e073e6caa2f8a4bd">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a419e3cc109a863c15fb8c0ce70a235a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419e3cc109a863c15fb8c0ce70a235a0">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code>value_type</code> created from <code>args</code>. </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a id="a932ef09bac6c32bef0f5888e9a67d2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932ef09bac6c32bef0f5888e9a67d2cd">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then assume that the set is empty. Thus, the correct item counting feature is an important part of split-list set implementation. </p>

</div>
</div>
<a id="a730086ffb1a533f013ca86bd43d1d719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730086ffb1a533f013ca86bd43d1d719">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f2c87cc75df17ac89786d9b7fc6c432">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a set. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the set. For empty set</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5b749193c0afb53019a23e55d056e30d">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a730086ffb1a533f013ca86bd43d1d719">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="ac2d9d2591d87d680e1e0942e28a636e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d9d2591d87d680e1e0942e28a636e8">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_erase_val"></a> Template parameter of type <code>Q</code> defines the key type searching in the list. The set item comparator should be able to compare the values of type <code>value_type</code> and the type <code>Q</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a0a2ad7d9963027c9f44c7a9e4bd7a2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ad7d9963027c9f44c7a9e4bd7a2ae">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a> <span class="keyword">const</span>&amp; val);</div><div class="line">};</div></div><!-- fragment --><p>Template parameter of type <code>Q</code> defines the key type searching in the list. The list item comparator should be able to compare the values of the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="ac0813e79767faec8708232805e1e63e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0813e79767faec8708232805e1e63e8">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="ad8e77899f2784acde39124d511b47c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e77899f2784acde39124d511b47c53">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="ada5a6c6c638569b385ff29083a6e82a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5a6c6c638569b385ff29083a6e82a4">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aff0fafed34cc602948088754cc91c9d2">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_extract"></a>The function searches an item with key equal to <code>key</code> in the set, unlinks it from the set, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item found. If the item with the key equal to <code>key</code> is not found the function returns an empty <code>exempt_ptr</code>.</p>
<p>Depends on <code>bucket_type</code> you should or should not lock RCU before calling of this function:</p><ul>
<li>for the set based on <a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_MichaelList_rcu">MichaelList</a> RCU should not be locked</li>
<li>for the set based on <a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_LazyList_rcu">LazyList</a> RCU should be locked See ordered list implementation for details.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; general_buffered&lt;&gt; &gt; rcu;</div><div class="line"></div><div class="line"><span class="comment">// Split-list set based on MichaelList by default</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; rcu, Foo &gt;</a> splitlist_set;</div><div class="line"></div><div class="line">splitlist_set theSet;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">splitlist_set::exempt_ptr p;</div><div class="line"></div><div class="line"><span class="comment">// For MichaelList we should not lock RCU</span></div><div class="line"></div><div class="line"><span class="comment">// Now, you can apply extract function</span></div><div class="line">p = theSet.<a class="code" href="classcds_1_1container_1_1_split_list_set.html#ab7636eacfce8c2960b7775a342938292">extract</a>( 10 );</div><div class="line"><span class="keywordflow">if</span> ( p ) {</div><div class="line">    <span class="comment">// do something with p</span></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// We may safely release p here</span></div><div class="line"><span class="comment">// release() passes the pointer to RCU reclamation cycle</span></div><div class="line">p.release();</div></div><!-- fragment --> 
</div>
</div>
<a id="a5e14835406eb6b8a008a6ddc75d08a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e14835406eb6b8a008a6ddc75d08a0d">&#9670;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aff0fafed34cc602948088754cc91c9d2">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ada5a6c6c638569b385ff29083a6e82a4" title="Extracts an item from the set. ">extract(Q const&amp;)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a5c5dc83748a948c863c9e960e7ccf520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5dc83748a948c863c9e960e7ccf520">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_find_func"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>&amp; item, Q&amp; key );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function makes RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="aaf61a70a84aa1116d913897217d195ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf61a70a84aa1116d913897217d195ec">&#9670;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a22a4e5e7b13f8a1d4cde1a020c1cd8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a4e5e7b13f8a1d4cde1a020c1cd8f6">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1ed04980c6c420658f8e540f92cee648">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListSet_rcu_get"></a>The function searches the item with key equal to <code>key</code> and returns the pointer to item found. If <code>key</code> is not found it returns <code>nullptr</code>.</p>
<p>Note the compare functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU should be locked before call of this function. Returned item is valid only while RCU is locked: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; general_buffered&lt;&gt; &gt; rcu;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; rcu, Foo &gt;</a> splitlist_set;</div><div class="line">splitlist_set theSet;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    <span class="comment">// Lock RCU</span></div><div class="line">    splitlist_set::rcu_lock lock;</div><div class="line"></div><div class="line">    foo * pVal = theSet.<a class="code" href="classcds_1_1container_1_1_split_list_set.html#a16d4175df387c0cf1fae98d485efa174">get</a>( 5 );</div><div class="line">    <span class="keywordflow">if</span> ( pVal ) {</div><div class="line">        <span class="comment">// Deal with pVal</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Unlock RCU by rcu_lock destructor</span></div><div class="line">    <span class="comment">// pVal can be retired by disposer at any time after RCU has been unlocked</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a2df123766832f05e9a7a07cda98379d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df123766832f05e9a7a07cda98379d3">&#9670;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a1ed04980c6c420658f8e540f92cee648">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SplitListSet_rcu_get">get(Q const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a5426434330a53312429d8d721fb66cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5426434330a53312429d8d721fb66cc7">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <code>value_type</code> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <code>value_type</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="adce3889ba7c9516fe71cca9f03c0e01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce3889ba7c9516fe71cca9f03c0e01b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>&amp; val );</div></div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a id="aa52416cc3418f86798d46512c526b075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52416cc3418f86798d46512c526b075">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">cds::urcu::gc</a>&lt; RCU &gt;, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates an element with given <code>val</code>. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val );</div><div class="line">};</div></div><!-- fragment --><p>with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>ensure</code>() function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set.Updates the node The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> is not found in the set, then <code>key</code> is inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found.</p>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a70ee3f6a13d5a1aa7b59cf26977fa4a3">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val );</div><div class="line">};</div></div><!-- fragment --><p>with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>update</code>() function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the map.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_MichaelList_rcu">MichaelList</a> as the bucket see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_LazyList_rcu">LazyList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/split_list_set_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:47:10 by Doxygen 1.8.13</i>
</div>
</body>
</html>
