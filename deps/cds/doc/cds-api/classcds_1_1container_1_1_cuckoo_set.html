<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::CuckooSet&lt; T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_cuckoo_set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::CuckooSet&lt; T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__set.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cuckoo hash set.  
 <a href="classcds_1_1container_1_1_cuckoo_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/cuckoo_set.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::CuckooSet&lt; T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_cuckoo_set.png" usemap="#cds::container::CuckooSet_3C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::CuckooSet_3C_20T_2C_20Traits_20_3E_map" name="cds::container::CuckooSet_3C_20T_2C_20Traits_20_3E_map">
<area href="classcds_1_1intrusive_1_1_cuckoo_set.html" title="Cuckoo hash set. " alt="cds::intrusive::CuckooSet&lt; T, Traits &gt;" shape="rect" coords="0,0,229,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6960090b98a1b6f318d12a0ded22ecbf"><td class="memItemLeft" align="right" valign="top"><a id="a6960090b98a1b6f318d12a0ded22ecbf"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a></td></tr>
<tr class="memdesc:a6960090b98a1b6f318d12a0ded22ecbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the container <br /></td></tr>
<tr class="separator:a6960090b98a1b6f318d12a0ded22ecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6275a0b0997a39330841cde0cc273cee"><td class="memItemLeft" align="right" valign="top"><a id="a6275a0b0997a39330841cde0cc273cee"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6275a0b0997a39330841cde0cc273cee">traits</a></td></tr>
<tr class="memdesc:a6275a0b0997a39330841cde0cc273cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits <br /></td></tr>
<tr class="separator:a6275a0b0997a39330841cde0cc273cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff3539a34964ef83520cb7acedb803d"><td class="memItemLeft" align="right" valign="top"><a id="a9ff3539a34964ef83520cb7acedb803d"></a>
typedef traits::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a9ff3539a34964ef83520cb7acedb803d">hash</a></td></tr>
<tr class="memdesc:a9ff3539a34964ef83520cb7acedb803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br /></td></tr>
<tr class="separator:a9ff3539a34964ef83520cb7acedb803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c874038de46f43becf699c9b8a1b5b"><td class="memItemLeft" align="right" valign="top"><a id="ad0c874038de46f43becf699c9b8a1b5b"></a>
typedef base_class::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a></td></tr>
<tr class="memdesc:ad0c874038de46f43becf699c9b8a1b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br /></td></tr>
<tr class="separator:ad0c874038de46f43becf699c9b8a1b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b0f96c71eeb8f15fffb0da4b8ee29"><td class="memItemLeft" align="right" valign="top"><a id="a9c9b0f96c71eeb8f15fffb0da4b8ee29"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a9c9b0f96c71eeb8f15fffb0da4b8ee29">mutex_policy</a></td></tr>
<tr class="memdesc:a9c9b0f96c71eeb8f15fffb0da4b8ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <a class="el" href="structcds_1_1container_1_1cuckoo_1_1traits.html#a40a7d6977e27e08e178e39521a43e07f" title="Concurrent access policy. ">cuckoo::traits::mutex_policy</a>. <br /></td></tr>
<tr class="separator:a9c9b0f96c71eeb8f15fffb0da4b8ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21b07f4df839096d3c4d111b83aaacd"><td class="memItemLeft" align="right" valign="top"><a id="ae21b07f4df839096d3c4d111b83aaacd"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae21b07f4df839096d3c4d111b83aaacd">stat</a></td></tr>
<tr class="memdesc:ae21b07f4df839096d3c4d111b83aaacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:ae21b07f4df839096d3c4d111b83aaacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cca666dbea78deddc8899da05617fb"><td class="memItemLeft" align="right" valign="top"><a id="a32cca666dbea78deddc8899da05617fb"></a>
typedef base_class::key_equal_to&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a32cca666dbea78deddc8899da05617fb">key_equal_to</a></td></tr>
<tr class="memdesc:a32cca666dbea78deddc8899da05617fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br /></td></tr>
<tr class="separator:a32cca666dbea78deddc8899da05617fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8617f0fae3ae5a6cf938adfd5d861f95"><td class="memItemLeft" align="right" valign="top"><a id="a8617f0fae3ae5a6cf938adfd5d861f95"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a8617f0fae3ae5a6cf938adfd5d861f95">key_comparator</a></td></tr>
<tr class="memdesc:a8617f0fae3ae5a6cf938adfd5d861f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <code>Traits::compare</code> and <code>Traits::less</code> option setter. Used only for ordered probe set <br /></td></tr>
<tr class="separator:a8617f0fae3ae5a6cf938adfd5d861f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1c93cb5f3a970c4c5ba9195d262979"><td class="memItemLeft" align="right" valign="top"><a id="a2e1c93cb5f3a970c4c5ba9195d262979"></a>
typedef base_class::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a2e1c93cb5f3a970c4c5ba9195d262979">allocator</a></td></tr>
<tr class="memdesc:a2e1c93cb5f3a970c4c5ba9195d262979"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type used for internal bucket table allocations <br /></td></tr>
<tr class="separator:a2e1c93cb5f3a970c4c5ba9195d262979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6c959e402cfa59f272a76f64f102f6"><td class="memItemLeft" align="right" valign="top"><a id="aeb6c959e402cfa59f272a76f64f102f6"></a>
typedef std::conditional&lt; std::is_same&lt; typename traits::node_allocator, <a class="el" href="structcds_1_1opt_1_1none.html">opt::none</a> &gt;::value, <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a2e1c93cb5f3a970c4c5ba9195d262979">allocator</a>, typename traits::node_allocator &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aeb6c959e402cfa59f272a76f64f102f6">node_allocator</a></td></tr>
<tr class="memdesc:aeb6c959e402cfa59f272a76f64f102f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator type. <br /></td></tr>
<tr class="separator:aeb6c959e402cfa59f272a76f64f102f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640d43d72b0bee66b28a3131eab7646f"><td class="memItemLeft" align="right" valign="top"><a id="a640d43d72b0bee66b28a3131eab7646f"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a640d43d72b0bee66b28a3131eab7646f">item_counter</a></td></tr>
<tr class="memdesc:a640d43d72b0bee66b28a3131eab7646f"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br /></td></tr>
<tr class="separator:a640d43d72b0bee66b28a3131eab7646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1101460328fbacaf3bdc4acd5c0e81e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1101460328fbacaf3bdc4acd5c0e81e7">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a1101460328fbacaf3bdc4acd5c0e81e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a1101460328fbacaf3bdc4acd5c0e81e7">More...</a><br /></td></tr>
<tr class="separator:a1101460328fbacaf3bdc4acd5c0e81e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba8f1383336b8f15853911a4414cb3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a9ba8f1383336b8f15853911a4414cb3f">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:a9ba8f1383336b8f15853911a4414cb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="#a9ba8f1383336b8f15853911a4414cb3f">More...</a><br /></td></tr>
<tr class="separator:a9ba8f1383336b8f15853911a4414cb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b3dacd480c537a3775a04166d19e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a296b3dacd480c537a3775a04166d19e9">CuckooSet</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a296b3dacd480c537a3775a04166d19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="#a296b3dacd480c537a3775a04166d19e9">More...</a><br /></td></tr>
<tr class="separator:a296b3dacd480c537a3775a04166d19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbb45c6bf31fd741fa17f3af1edaca6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aafbb45c6bf31fd741fa17f3af1edaca6">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:aafbb45c6bf31fd741fa17f3af1edaca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="#aafbb45c6bf31fd741fa17f3af1edaca6">More...</a><br /></td></tr>
<tr class="separator:aafbb45c6bf31fd741fa17f3af1edaca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907edd06474f7cc1d153b35c7747c5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aa907edd06474f7cc1d153b35c7747c5c">CuckooSet</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aa907edd06474f7cc1d153b35c7747c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="#aa907edd06474f7cc1d153b35c7747c5c">More...</a><br /></td></tr>
<tr class="separator:aa907edd06474f7cc1d153b35c7747c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa844c23eee0a1f388f732477483b33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a2aa844c23eee0a1f388f732477483b33">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a2aa844c23eee0a1f388f732477483b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="#a2aa844c23eee0a1f388f732477483b33">More...</a><br /></td></tr>
<tr class="separator:a2aa844c23eee0a1f388f732477483b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aeb06f0bf4632b93b9c9a6e1f59332"><td class="memItemLeft" align="right" valign="top"><a id="a21aeb06f0bf4632b93b9c9a6e1f59332"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a21aeb06f0bf4632b93b9c9a6e1f59332">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a21aeb06f0bf4632b93b9c9a6e1f59332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears the set. <br /></td></tr>
<tr class="separator:a21aeb06f0bf4632b93b9c9a6e1f59332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31094d63170ecc65adfba66f838e4736"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a31094d63170ecc65adfba66f838e4736"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a31094d63170ecc65adfba66f838e4736">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a31094d63170ecc65adfba66f838e4736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a31094d63170ecc65adfba66f838e4736">More...</a><br /></td></tr>
<tr class="separator:a31094d63170ecc65adfba66f838e4736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf139c50172cf26e3d94a7c7141c562"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aabf139c50172cf26e3d94a7c7141c562"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#aabf139c50172cf26e3d94a7c7141c562">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:aabf139c50172cf26e3d94a7c7141c562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#aabf139c50172cf26e3d94a7c7141c562">More...</a><br /></td></tr>
<tr class="separator:aabf139c50172cf26e3d94a7c7141c562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4453ff789e62ed077d47d3d6099e22"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9a4453ff789e62ed077d47d3d6099e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a9a4453ff789e62ed077d47d3d6099e22">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9a4453ff789e62ed077d47d3d6099e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a9a4453ff789e62ed077d47d3d6099e22">More...</a><br /></td></tr>
<tr class="separator:a9a4453ff789e62ed077d47d3d6099e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508c2899a48d810de6718d50a3ecb562"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a508c2899a48d810de6718d50a3ecb562"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a508c2899a48d810de6718d50a3ecb562">update</a> (Q const &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a508c2899a48d810de6718d50a3ecb562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a508c2899a48d810de6718d50a3ecb562">More...</a><br /></td></tr>
<tr class="separator:a508c2899a48d810de6718d50a3ecb562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a600a2a1f6dee844efa7732c9c37fdbe8">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a600a2a1f6dee844efa7732c9c37fdbe8">More...</a><br /></td></tr>
<tr class="separator:a600a2a1f6dee844efa7732c9c37fdbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1cb6ddf92a91d5aa73758d4dd78b03a3">erase_with</a> (Q const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a1cb6ddf92a91d5aa73758d4dd78b03a3">More...</a><br /></td></tr>
<tr class="separator:a1cb6ddf92a91d5aa73758d4dd78b03a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087593ff478f76db232f7e6ba664e2a"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae087593ff478f76db232f7e6ba664e2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae087593ff478f76db232f7e6ba664e2a">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:ae087593ff478f76db232f7e6ba664e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#ae087593ff478f76db232f7e6ba664e2a">More...</a><br /></td></tr>
<tr class="separator:ae087593ff478f76db232f7e6ba664e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e746d9a12ec6a109364f57383296b9b"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a0e746d9a12ec6a109364f57383296b9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a0e746d9a12ec6a109364f57383296b9b">erase_with</a> (Q const &amp;key, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a0e746d9a12ec6a109364f57383296b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a0e746d9a12ec6a109364f57383296b9b">More...</a><br /></td></tr>
<tr class="separator:a0e746d9a12ec6a109364f57383296b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a8bc2faf556b0509b97dc9f45ca0ca814">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a8bc2faf556b0509b97dc9f45ca0ca814">More...</a><br /></td></tr>
<tr class="separator:a8bc2faf556b0509b97dc9f45ca0ca814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf720dc7a1496938965d5c3ae9a090"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a90bf720dc7a1496938965d5c3ae9a090"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a90bf720dc7a1496938965d5c3ae9a090">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a90bf720dc7a1496938965d5c3ae9a090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a90bf720dc7a1496938965d5c3ae9a090">More...</a><br /></td></tr>
<tr class="separator:a90bf720dc7a1496938965d5c3ae9a090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667f8c7a6c6759e537f759535e4d1ebb"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a667f8c7a6c6759e537f759535e4d1ebb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a667f8c7a6c6759e537f759535e4d1ebb">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a667f8c7a6c6759e537f759535e4d1ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#a667f8c7a6c6759e537f759535e4d1ebb">More...</a><br /></td></tr>
<tr class="separator:a667f8c7a6c6759e537f759535e4d1ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7cf932bc8645eb3051f72c519a49a6"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a6e7cf932bc8645eb3051f72c519a49a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6e7cf932bc8645eb3051f72c519a49a6">contains</a> (Q const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a6e7cf932bc8645eb3051f72c519a49a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a6e7cf932bc8645eb3051f72c519a49a6">More...</a><br /></td></tr>
<tr class="separator:a6e7cf932bc8645eb3051f72c519a49a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a224c06b767df1f39e5eb7fb3625a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a17a224c06b767df1f39e5eb7fb3625a5">clear</a> ()</td></tr>
<tr class="memdesc:a17a224c06b767df1f39e5eb7fb3625a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#a17a224c06b767df1f39e5eb7fb3625a5">More...</a><br /></td></tr>
<tr class="separator:a17a224c06b767df1f39e5eb7fb3625a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c4d2a9d75e4a261195bb1f13865c0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#af4c4d2a9d75e4a261195bb1f13865c0d">empty</a> () const</td></tr>
<tr class="memdesc:af4c4d2a9d75e4a261195bb1f13865c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#af4c4d2a9d75e4a261195bb1f13865c0d">More...</a><br /></td></tr>
<tr class="separator:af4c4d2a9d75e4a261195bb1f13865c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cdb479f7800cced72314129bbebb25"><td class="memItemLeft" align="right" valign="top"><a id="a80cdb479f7800cced72314129bbebb25"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a80cdb479f7800cced72314129bbebb25">size</a> () const</td></tr>
<tr class="memdesc:a80cdb479f7800cced72314129bbebb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a80cdb479f7800cced72314129bbebb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d3ced409c754153b585be05a85e00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a584d3ced409c754153b585be05a85e00">bucket_count</a> () const</td></tr>
<tr class="memdesc:a584d3ced409c754153b585be05a85e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a584d3ced409c754153b585be05a85e00">More...</a><br /></td></tr>
<tr class="separator:a584d3ced409c754153b585be05a85e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a543029dddea743678c380a305ff1a"><td class="memItemLeft" align="right" valign="top"><a id="a92a543029dddea743678c380a305ff1a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a92a543029dddea743678c380a305ff1a">lock_count</a> () const</td></tr>
<tr class="memdesc:a92a543029dddea743678c380a305ff1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a92a543029dddea743678c380a305ff1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0ba4c0667953b09aa31abcfdd00221"><td class="memItemLeft" align="right" valign="top"><a id="ade0ba4c0667953b09aa31abcfdd00221"></a>
<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae21b07f4df839096d3c4d111b83aaacd">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ade0ba4c0667953b09aa31abcfdd00221">statistics</a> () const</td></tr>
<tr class="memdesc:ade0ba4c0667953b09aa31abcfdd00221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:ade0ba4c0667953b09aa31abcfdd00221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae863947ec6c3409abe834ff786dc9981"><td class="memItemLeft" align="right" valign="top"><a id="ae863947ec6c3409abe834ff786dc9981"></a>
mutex_policy::statistics_type const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ae863947ec6c3409abe834ff786dc9981">mutex_policy_statistics</a> () const</td></tr>
<tr class="memdesc:ae863947ec6c3409abe834ff786dc9981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br /></td></tr>
<tr class="separator:ae863947ec6c3409abe834ff786dc9981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6777b15dc90e121ace8db149316274c2"><td class="memItemLeft" align="right" valign="top"><a id="a6777b15dc90e121ace8db149316274c2"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6777b15dc90e121ace8db149316274c2">c_isSorted</a> = base_class::c_isSorted</td></tr>
<tr class="memdesc:a6777b15dc90e121ace8db149316274c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered <br /></td></tr>
<tr class="separator:a6777b15dc90e121ace8db149316274c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab919ab7745976c25c78f3690ef211a93"><td class="memItemLeft" align="right" valign="top"><a id="ab919ab7745976c25c78f3690ef211a93"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> = base_class::c_nArity</td></tr>
<tr class="memdesc:ab919ab7745976c25c78f3690ef211a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br /></td></tr>
<tr class="separator:ab919ab7745976c25c78f3690ef211a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029af01b7f4957161b5d1852f8deb22e"><td class="memItemLeft" align="right" valign="top"><a id="a029af01b7f4957161b5d1852f8deb22e"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a029af01b7f4957161b5d1852f8deb22e">c_nDefaultProbesetSize</a> = base_class::c_nDefaultProbesetSize</td></tr>
<tr class="memdesc:a029af01b7f4957161b5d1852f8deb22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br /></td></tr>
<tr class="separator:a029af01b7f4957161b5d1852f8deb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99951f1c472fe6bc40ed35693f4df992"><td class="memItemLeft" align="right" valign="top"><a id="a99951f1c472fe6bc40ed35693f4df992"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> = base_class::c_nDefaultInitialSize</td></tr>
<tr class="memdesc:a99951f1c472fe6bc40ed35693f4df992"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br /></td></tr>
<tr class="separator:a99951f1c472fe6bc40ed35693f4df992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a56f8c2c7c3ea18231390af8a9164cd"><td class="memItemLeft" align="right" valign="top"><a id="a6a56f8c2c7c3ea18231390af8a9164cd"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6a56f8c2c7c3ea18231390af8a9164cd">c_nRelocateLimit</a> = base_class::c_nRelocateLimit</td></tr>
<tr class="memdesc:a6a56f8c2c7c3ea18231390af8a9164cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br /></td></tr>
<tr class="separator:a6a56f8c2c7c3ea18231390af8a9164cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:a80f3988a87de588e0a2d873592e6da40 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a80f3988a87de588e0a2d873592e6da40"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a></td></tr>
<tr class="memdesc:a80f3988a87de588e0a2d873592e6da40 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type stored in the set. <br /></td></tr>
<tr class="separator:a80f3988a87de588e0a2d873592e6da40 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092995180143580f5c99ee285127c6c9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a092995180143580f5c99ee285127c6c9"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a></td></tr>
<tr class="memdesc:a092995180143580f5c99ee285127c6c9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br /></td></tr>
<tr class="separator:a092995180143580f5c99ee285127c6c9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282e600d3e6eec649b6237d6834ffc52 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a282e600d3e6eec649b6237d6834ffc52"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a></td></tr>
<tr class="memdesc:a282e600d3e6eec649b6237d6834ffc52 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a282e600d3e6eec649b6237d6834ffc52 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d55d2a0fff222284b2d978b7a0985d inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a11d55d2a0fff222284b2d978b7a0985d"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a></td></tr>
<tr class="memdesc:a11d55d2a0fff222284b2d978b7a0985d inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:a11d55d2a0fff222284b2d978b7a0985d inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af0e1eb823a6d2f1c557686c912c605 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a9af0e1eb823a6d2f1c557686c912c605"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9af0e1eb823a6d2f1c557686c912c605">node_traits</a></td></tr>
<tr class="memdesc:a9af0e1eb823a6d2f1c557686c912c605 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:a9af0e1eb823a6d2f1c557686c912c605 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb19f8057ca1bb84b31722b2d287c4f3 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="aeb19f8057ca1bb84b31722b2d287c4f3"></a>
typedef traits::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a></td></tr>
<tr class="memdesc:aeb19f8057ca1bb84b31722b2d287c4f3 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br /></td></tr>
<tr class="separator:aeb19f8057ca1bb84b31722b2d287c4f3 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109563a562d2cc52f6819b272923dfa7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a109563a562d2cc52f6819b272923dfa7"></a>
typedef hash::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a></td></tr>
<tr class="memdesc:a109563a562d2cc52f6819b272923dfa7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br /></td></tr>
<tr class="separator:a109563a562d2cc52f6819b272923dfa7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44220cb2b6696715e2e902c07a13e330 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a44220cb2b6696715e2e902c07a13e330"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a></td></tr>
<tr class="memdesc:a44220cb2b6696715e2e902c07a13e330 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:a44220cb2b6696715e2e902c07a13e330 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45ae046c619faae22f2f16f5ba6f6c inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a3f45ae046c619faae22f2f16f5ba6f6c"></a>
typedef traits::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3f45ae046c619faae22f2f16f5ba6f6c">original_mutex_policy</a></td></tr>
<tr class="memdesc:a3f45ae046c619faae22f2f16f5ba6f6c inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html#af601783d33a04234fc6fad8d2235b349" title="Concurrent access policy. ">cuckoo::traits::mutex_policy</a></code>. <br /></td></tr>
<tr class="separator:a3f45ae046c619faae22f2f16f5ba6f6c inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7de3b1f961e712b85e967df7e762b4 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="aef7de3b1f961e712b85e967df7e762b4"></a>
typedef opt::details::make_equal_to&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a>, !<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aef7de3b1f961e712b85e967df7e762b4">key_equal_to</a></td></tr>
<tr class="memdesc:aef7de3b1f961e712b85e967df7e762b4 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br /></td></tr>
<tr class="separator:aef7de3b1f961e712b85e967df7e762b4 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6cc0f5f964eaef3a8559c2e0377263 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a8c6cc0f5f964eaef3a8559c2e0377263"></a>
typedef opt::details::make_comparator&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8c6cc0f5f964eaef3a8559c2e0377263">key_comparator</a></td></tr>
<tr class="memdesc:a8c6cc0f5f964eaef3a8559c2e0377263 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a></code> and <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a></code> option setter. Used only for ordered probe set <br /></td></tr>
<tr class="separator:a8c6cc0f5f964eaef3a8559c2e0377263 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c29caeacd9eab62a8295cb776f65ca7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a1c29caeacd9eab62a8295cb776f65ca7"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1c29caeacd9eab62a8295cb776f65ca7">allocator</a></td></tr>
<tr class="memdesc:a1c29caeacd9eab62a8295cb776f65ca7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type <br /></td></tr>
<tr class="separator:a1c29caeacd9eab62a8295cb776f65ca7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4384afbdc9b2688c6175aafd3bbb85a9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a4384afbdc9b2688c6175aafd3bbb85a9"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a4384afbdc9b2688c6175aafd3bbb85a9">item_counter</a></td></tr>
<tr class="memdesc:a4384afbdc9b2688c6175aafd3bbb85a9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br /></td></tr>
<tr class="separator:a4384afbdc9b2688c6175aafd3bbb85a9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93619c3ddbc8fc96a0b6481de8e03126 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a93619c3ddbc8fc96a0b6481de8e03126"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a93619c3ddbc8fc96a0b6481de8e03126">disposer</a></td></tr>
<tr class="memdesc:a93619c3ddbc8fc96a0b6481de8e03126 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node disposer <br /></td></tr>
<tr class="separator:a93619c3ddbc8fc96a0b6481de8e03126 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367">More...</a><br /></td></tr>
<tr class="separator:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f71b08de102c3ca85b9bc53963b38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac18f71b08de102c3ca85b9bc53963b38">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:ac18f71b08de102c3ca85b9bc53963b38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac18f71b08de102c3ca85b9bc53963b38">More...</a><br /></td></tr>
<tr class="separator:ac18f71b08de102c3ca85b9bc53963b38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cec0e76f68e4d0462420d577c728c76 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a2cec0e76f68e4d0462420d577c728c76">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a2cec0e76f68e4d0462420d577c728c76 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a2cec0e76f68e4d0462420d577c728c76">More...</a><br /></td></tr>
<tr class="separator:a2cec0e76f68e4d0462420d577c728c76 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a028ecfbae605b0199e0b0b2d15fd3d73">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a028ecfbae605b0199e0b0b2d15fd3d73">More...</a><br /></td></tr>
<tr class="separator:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f68f38da3654e56754e08c94f66d2e inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95f68f38da3654e56754e08c94f66d2e">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a95f68f38da3654e56754e08c94f66d2e inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95f68f38da3654e56754e08c94f66d2e">More...</a><br /></td></tr>
<tr class="separator:a95f68f38da3654e56754e08c94f66d2e inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede715e446da90de4e51b19d64236da3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aede715e446da90de4e51b19d64236da3">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aede715e446da90de4e51b19d64236da3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#aede715e446da90de4e51b19d64236da3">More...</a><br /></td></tr>
<tr class="separator:aede715e446da90de4e51b19d64236da3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545595f7caba3bdd3520e16115a7fa2b inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a545595f7caba3bdd3520e16115a7fa2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a545595f7caba3bdd3520e16115a7fa2b">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a545595f7caba3bdd3520e16115a7fa2b inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a545595f7caba3bdd3520e16115a7fa2b inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75199d012de6ab7c3315dda78b4b3025 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a75199d012de6ab7c3315dda78b4b3025">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a75199d012de6ab7c3315dda78b4b3025 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a75199d012de6ab7c3315dda78b4b3025">More...</a><br /></td></tr>
<tr class="separator:a75199d012de6ab7c3315dda78b4b3025 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a103ae7f5ebd72ac7fe2a1cc751f937bd">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a103ae7f5ebd72ac7fe2a1cc751f937bd">More...</a><br /></td></tr>
<tr class="separator:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1341ac3ce1c85b0f84c041132d42ec1a">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1341ac3ce1c85b0f84c041132d42ec1a">More...</a><br /></td></tr>
<tr class="separator:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2d0ae24a2a32edc066a96e003e9bb inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44c2d0ae24a2a32edc066a96e003e9bb">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a44c2d0ae24a2a32edc066a96e003e9bb inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44c2d0ae24a2a32edc066a96e003e9bb">More...</a><br /></td></tr>
<tr class="separator:a44c2d0ae24a2a32edc066a96e003e9bb inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9b4514beb5a17fa560faca26c3134e38">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9b4514beb5a17fa560faca26c3134e38">More...</a><br /></td></tr>
<tr class="separator:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a664d70addf3f701f1a62013c69355790">erase_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a664d70addf3f701f1a62013c69355790">More...</a><br /></td></tr>
<tr class="separator:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a7036d8b2985726d5cb138c879d016a44">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a7036d8b2985726d5cb138c879d016a44">More...</a><br /></td></tr>
<tr class="separator:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a213ba3e87c26e5a1afcc84e7cea477ad">erase_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a213ba3e87c26e5a1afcc84e7cea477ad">More...</a><br /></td></tr>
<tr class="separator:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a578457cdff461f79ba9e57515d851b71">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a578457cdff461f79ba9e57515d851b71">More...</a><br /></td></tr>
<tr class="separator:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a783b11c482e9e855ec9d207262aefd75">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a783b11c482e9e855ec9d207262aefd75">More...</a><br /></td></tr>
<tr class="separator:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a753b31e6fa9114cd1d95471ee057b6a2">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a753b31e6fa9114cd1d95471ee057b6a2">More...</a><br /></td></tr>
<tr class="separator:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a10d7acb708e5cfc7488b2d5fb584e6f9">contains</a> (Q const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a10d7acb708e5cfc7488b2d5fb584e6f9">More...</a><br /></td></tr>
<tr class="separator:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#adc138e7fd59de4e6a8e0ce6fc13b3f20">clear</a> ()</td></tr>
<tr class="memdesc:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#adc138e7fd59de4e6a8e0ce6fc13b3f20">More...</a><br /></td></tr>
<tr class="separator:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplParams" colspan="2">template&lt;typename Disposer &gt; </td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a23148d079b580ccc0a9141094b9534ee">clear_and_dispose</a> (Disposer oDisposer)</td></tr>
<tr class="memdesc:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a23148d079b580ccc0a9141094b9534ee">More...</a><br /></td></tr>
<tr class="separator:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4054cc5d2d9188e9a1f7dc0457a7018 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad4054cc5d2d9188e9a1f7dc0457a7018">empty</a> () const</td></tr>
<tr class="memdesc:ad4054cc5d2d9188e9a1f7dc0457a7018 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad4054cc5d2d9188e9a1f7dc0457a7018">More...</a><br /></td></tr>
<tr class="separator:ad4054cc5d2d9188e9a1f7dc0457a7018 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dce7a98ed8d4626bb1c2e9672dffc2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a84dce7a98ed8d4626bb1c2e9672dffc2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a84dce7a98ed8d4626bb1c2e9672dffc2">size</a> () const</td></tr>
<tr class="memdesc:a84dce7a98ed8d4626bb1c2e9672dffc2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a84dce7a98ed8d4626bb1c2e9672dffc2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe99a77d44fc4f1099a9a3c2affc33d inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8fe99a77d44fc4f1099a9a3c2affc33d">bucket_count</a> () const</td></tr>
<tr class="memdesc:a8fe99a77d44fc4f1099a9a3c2affc33d inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8fe99a77d44fc4f1099a9a3c2affc33d">More...</a><br /></td></tr>
<tr class="separator:a8fe99a77d44fc4f1099a9a3c2affc33d inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c76acd490b84ce210189b49b7cd1897 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a8c76acd490b84ce210189b49b7cd1897"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8c76acd490b84ce210189b49b7cd1897">lock_count</a> () const</td></tr>
<tr class="memdesc:a8c76acd490b84ce210189b49b7cd1897 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a8c76acd490b84ce210189b49b7cd1897 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c315c3c0639fdc8f6eb95ec9c2de1 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="abd0c315c3c0639fdc8f6eb95ec9c2de1"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#abd0c315c3c0639fdc8f6eb95ec9c2de1">statistics</a> () const</td></tr>
<tr class="memdesc:abd0c315c3c0639fdc8f6eb95ec9c2de1 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:abd0c315c3c0639fdc8f6eb95ec9c2de1 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846653e92450dfb38d9a217b1405ee3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="ae846653e92450dfb38d9a217b1405ee3"></a>
mutex_policy::statistics_type const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ae846653e92450dfb38d9a217b1405ee3">mutex_policy_statistics</a> () const</td></tr>
<tr class="memdesc:ae846653e92450dfb38d9a217b1405ee3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br /></td></tr>
<tr class="separator:ae846653e92450dfb38d9a217b1405ee3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:a904af372de54c256d49de92ba849814d inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a904af372de54c256d49de92ba849814d"></a>
bucket_entry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a904af372de54c256d49de92ba849814d">m_BucketTable</a> [<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a>]</td></tr>
<tr class="memdesc:a904af372de54c256d49de92ba849814d inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket tables. <br /></td></tr>
<tr class="separator:a904af372de54c256d49de92ba849814d inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df0bbf3e71dbb842c2210122593fdf inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a86df0bbf3e71dbb842c2210122593fdf"></a>
atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a86df0bbf3e71dbb842c2210122593fdf">m_nBucketMask</a></td></tr>
<tr class="memdesc:a86df0bbf3e71dbb842c2210122593fdf inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash bitmask; bucket table size minus 1. <br /></td></tr>
<tr class="separator:a86df0bbf3e71dbb842c2210122593fdf inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96855242b5e8df7673689fce275e6410 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a96855242b5e8df7673689fce275e6410"></a>
unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a96855242b5e8df7673689fce275e6410">m_nProbesetSize</a></td></tr>
<tr class="memdesc:a96855242b5e8df7673689fce275e6410 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set size. <br /></td></tr>
<tr class="separator:a96855242b5e8df7673689fce275e6410 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a50b187e648a3855129792ba90ed05 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a80a50b187e648a3855129792ba90ed05"></a>
unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80a50b187e648a3855129792ba90ed05">m_nProbesetThreshold</a></td></tr>
<tr class="memdesc:a80a50b187e648a3855129792ba90ed05 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set threshold. <br /></td></tr>
<tr class="separator:a80a50b187e648a3855129792ba90ed05 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c17058bb63f1b7b32e174642b2d0a31 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a6c17058bb63f1b7b32e174642b2d0a31"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a6c17058bb63f1b7b32e174642b2d0a31">m_Hash</a></td></tr>
<tr class="memdesc:a6c17058bb63f1b7b32e174642b2d0a31 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor tuple. <br /></td></tr>
<tr class="separator:a6c17058bb63f1b7b32e174642b2d0a31 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b55f3a0eb6ad233feee8b9917abaa4 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="aa3b55f3a0eb6ad233feee8b9917abaa4"></a>
mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa3b55f3a0eb6ad233feee8b9917abaa4">m_MutexPolicy</a></td></tr>
<tr class="memdesc:aa3b55f3a0eb6ad233feee8b9917abaa4 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">concurrent access policy <br /></td></tr>
<tr class="separator:aa3b55f3a0eb6ad233feee8b9917abaa4 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a84f7b7af5ed6cb9f18ff528d41aae2 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a8a84f7b7af5ed6cb9f18ff528d41aae2"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a4384afbdc9b2688c6175aafd3bbb85a9">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8a84f7b7af5ed6cb9f18ff528d41aae2">m_ItemCounter</a></td></tr>
<tr class="memdesc:a8a84f7b7af5ed6cb9f18ff528d41aae2 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br /></td></tr>
<tr class="separator:a8a84f7b7af5ed6cb9f18ff528d41aae2 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac364bc421fc0fe5cce1ed31d99faa74a inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="ac364bc421fc0fe5cce1ed31d99faa74a"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac364bc421fc0fe5cce1ed31d99faa74a">m_Stat</a></td></tr>
<tr class="memdesc:ac364bc421fc0fe5cce1ed31d99faa74a inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:ac364bc421fc0fe5cce1ed31d99faa74a inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; T, Traits &gt;</a></td></tr>
<tr class="memitem:aec91125eaafeba9da642a4ec74fd7c0f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a></td></tr>
<tr class="memdesc:aec91125eaafeba9da642a4ec74fd7c0f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set should be ordered or not.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">More...</a><br /></td></tr>
<tr class="separator:aec91125eaafeba9da642a4ec74fd7c0f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57c3ed1e36757238a5396a667eeb06f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="af57c3ed1e36757238a5396a667eeb06f"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> = hash::size</td></tr>
<tr class="memdesc:af57c3ed1e36757238a5396a667eeb06f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br /></td></tr>
<tr class="separator:af57c3ed1e36757238a5396a667eeb06f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7428e959608e5decac221dc317e8da8 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="aa7428e959608e5decac221dc317e8da8"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa7428e959608e5decac221dc317e8da8">c_nDefaultProbesetSize</a> = 4</td></tr>
<tr class="memdesc:aa7428e959608e5decac221dc317e8da8 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br /></td></tr>
<tr class="separator:aa7428e959608e5decac221dc317e8da8 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3b066d9b88fd5ec69263a5783ac17 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="a49f3b066d9b88fd5ec69263a5783ac17"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a49f3b066d9b88fd5ec69263a5783ac17">c_nDefaultInitialSize</a> = 16</td></tr>
<tr class="memdesc:a49f3b066d9b88fd5ec69263a5783ac17 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br /></td></tr>
<tr class="separator:a49f3b066d9b88fd5ec69263a5783ac17 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb27b2754ff51b10ee5e7754aafec36 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a id="aceb27b2754ff51b10ee5e7754aafec36"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aceb27b2754ff51b10ee5e7754aafec36">c_nRelocateLimit</a> = <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> * 2 - 1</td></tr>
<tr class="memdesc:aceb27b2754ff51b10ee5e7754aafec36 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br /></td></tr>
<tr class="separator:aceb27b2754ff51b10ee5e7754aafec36 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Traits = cuckoo::traits&gt;<br />
class cds::container::CuckooSet&lt; T, Traits &gt;</h3>

<p>Cuckoo hash set. </p>
<p>Source</p><ul>
<li>[2007] M.Herlihy, N.Shavit, M.Tzafrir "Concurrent Cuckoo Hashing. Technical report"</li>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p><b>About Cuckoo hashing</b></p>
<p>[From "The Art of Multiprocessor Programming"] <a href="https://en.wikipedia.org/wiki/Cuckoo_hashing">Cuckoo hashing</a> is a hashing algorithm in which a newly added item displaces any earlier item occupying the same slot. For brevity, a table is a k-entry array of items. For a hash set f size N = 2k we use a two-entry array of tables, and two independent hash functions, <code> h0, h1: KeyRange -&gt; 0,...,k-1</code> mapping the set of possible keys to entries in he array. To test whether a value <code>x</code> is in the set, <code>find(x)</code> tests whether either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code> is equal to <code>x</code>. Similarly, <code>erase(x)</code>checks whether <code>x</code> is in either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code>, ad removes it if found.</p>
<p>The <code>insert(x)</code> successively "kicks out" conflicting items until every key has a slot. To add <code>x</code>, the method swaps <code>x</code> with <code>y</code>, the current occupant of <code>table[0][h0(x)]</code>. If the prior value was <code>nullptr</code>, it is done. Otherwise, it swaps the newly nest-less value <code>y</code> for the current occupant of <code>table[1][h1(y)]</code> in the same way. As before, if the prior value was <code>nullptr</code>, it is done. Otherwise, the method continues swapping entries (alternating tables) until it finds an empty slot. We might not find an empty slot, either because the table is full, or because the sequence of displacement forms a cycle. We therefore need an upper limit on the number of successive displacements we are willing to undertake. When this limit is exceeded, we resize the hash table, choose new hash functions and start over.</p>
<p>For concurrent cuckoo hashing, rather than organizing the set as a two-dimensional table of items, we use two-dimensional table of probe sets, where a probe set is a constant-sized set of items with the same hash code. Each probe set holds at most <code>PROBE_SIZE</code> items, but the algorithm tries to ensure that when the set is quiescent (i.e no method call in progress) each probe set holds no more than <code>THRESHOLD &lt; PROBE_SET</code> items. While method calls are in-flight, a probe set may temporarily hold more than <code>THRESHOLD</code> but never more than <code>PROBE_SET</code> items.</p>
<p>In current implementation, a probe set can be defined either as a (single-linked) list or as a fixed-sized vector, optionally ordered.</p>
<p>In description above two-table cuckoo hashing (<code>k = 2</code>) has been considered. We can generalize this approach for <code>k &gt;= 2</code> when we have <code>k</code> hash functions <code>h[0], ... h[k-1]</code> and <code>k</code> tables <code>table[0], ... table[k-1]</code>.</p>
<p>The search in probe set is linear, the complexity is <code> O(PROBE_SET) </code>. The probe set may be ordered or not. Ordered probe set can be a little better since the average search complexity is <code>O(PROBE_SET/2)</code>. However, the overhead of sorting can eliminate a gain of ordered search.</p>
<p>The probe set is ordered if <code>compare</code> or <code>less</code> is specified in <code>Traits</code> template parameter. Otherwise, the probe set is unordered and <code>Traits</code> must contain <code>equal_to</code> predicate.</p>
<p>Template arguments:</p><ul>
<li><code>T</code> - the type stored in the set.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1cuckoo_1_1traits.html" title="Type traits for CuckooSet and CuckooMap classes. ">cuckoo::traits</a> for explanation. It is possible to declare option-based set with <a class="el" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits. ">cuckoo::make_traits</a> metafunction result as <code>Traits</code> template argument.</li>
</ul>
<p><b>Examples</b></p>
<p>Cuckoo-set with list-based unordered probe set and storing hash values </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Data stored in cuckoo set</span></div><div class="line"><span class="keyword">struct </span>my_data</div><div class="line">{</div><div class="line">    <span class="comment">// key field</span></div><div class="line">    std::string     strKey;</div><div class="line"></div><div class="line">    <span class="comment">// other data</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide equal_to functor for my_data since we will use unordered probe-set</span></div><div class="line"><span class="keyword">struct </span>my_data_equal_to {</div><div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey ) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey ) == 0;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide two hash functor for my_data</span></div><div class="line"><span class="keyword">struct </span>hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s );</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s));</div><div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare type traits</span></div><div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1traits.html">cds::container::cuckoo::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> my_data_equa_to equal_to;</div><div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a9ff3539a34964ef83520cb7acedb803d">hash</a>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = <span class="keyword">true</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare CuckooSet type</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet&lt; my_data, my_traits &gt;</a> my_cuckoo_set;</div><div class="line"></div><div class="line"><span class="comment">// Equal option-based declaration</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; my_data,</div><div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html">cds::container::cuckoo::make_traits</a>&lt;</div><div class="line">        cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt; &gt;</div><div class="line">        ,<a class="code" href="structcds_1_1opt_1_1equal__to.html">cds::opt::equal_to&lt; my_data_equal_to &gt;</a></div><div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html">cds::container::cuckoo::store_hash&lt; true &gt;</a></div><div class="line">    &gt;::type</div><div class="line">&gt; opt_cuckoo_set;</div></div><!-- fragment --><p>If we provide <code>compare</code> function instead of <code>equal_to</code> for <code>my_data</code> we get as a result a cuckoo set with ordered probe set that may improve performance. Example for ordered vector-based probe-set:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Data stored in cuckoo set</span></div><div class="line"><span class="keyword">struct </span>my_data</div><div class="line">{</div><div class="line">    <span class="comment">// key field</span></div><div class="line">    std::string     strKey;</div><div class="line"></div><div class="line">    <span class="comment">// other data</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide compare functor for my_data since we want to use ordered probe-set</span></div><div class="line"><span class="keyword">struct </span>my_data_compare {</div><div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide two hash functor for my_data</span></div><div class="line"><span class="keyword">struct </span>hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s );</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s));</div><div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare type traits</span></div><div class="line"><span class="comment">// We use a vector of capacity 4 as probe-set container and store hash values in the node</span></div><div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1traits.html">cds::container::cuckoo::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> my_data_compare compare;</div><div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a9ff3539a34964ef83520cb7acedb803d">hash</a>;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1vector.html">cds::container::cuckoo::vector&lt;4&gt;</a> probeset_type;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = <span class="keyword">true</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare CuckooSet type</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet&lt; my_data, my_traits &gt;</a> my_cuckoo_set;</div><div class="line"></div><div class="line"><span class="comment">// Equal option-based declaration</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; my_data,</div><div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html">cds::container::cuckoo::make_traits</a>&lt;</div><div class="line">        cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt; &gt;</div><div class="line">        ,<a class="code" href="structcds_1_1opt_1_1compare.html">cds::opt::compare&lt; my_data_compare &gt;</a></div><div class="line">        ,cds::container::cuckoo::probeset_type&lt; cds::container::cuckoo::vector&lt;4&gt; &gt;</div><div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html">cds::container::cuckoo::store_hash&lt; true &gt;</a></div><div class="line">    &gt;::type</div><div class="line">&gt; opt_cuckoo_set;</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1101460328fbacaf3bdc4acd5c0e81e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1101460328fbacaf3bdc4acd5c0e81e7">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initial size = <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a></p>
<p>Probe set size:</p><ul>
<li><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a029af01b7f4957161b5d1852f8deb22e">c_nDefaultProbesetSize</a> if <code>probeset_type</code> is <code>cuckoo::list</code> </li>
<li><code>Capacity</code> if <code>probeset_type</code> is <code> cuckoo::vector&lt;Capacity&gt; </code></li>
</ul>
<p>Probe set threshold = probe set size - 1 </p>

</div>
</div>
<a id="a9ba8f1383336b8f15853911a4414cb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba8f1383336b8f15853911a4414cb3f">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set size and threshold. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a296b3dacd480c537a3775a04166d19e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296b3dacd480c537a3775a04166d19e9">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given hash functor tuple. </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1101460328fbacaf3bdc4acd5c0e81e7" title="Default constructor. ">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafbb45c6bf31fd741fa17f3af1edaca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbb45c6bf31fd741fa17f3af1edaca6">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set properties and hash functor tuple. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa907edd06474f7cc1d153b35c7747c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa907edd06474f7cc1d153b35c7747c5c">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given hash functor tuple (move semantics) </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a1101460328fbacaf3bdc4acd5c0e81e7" title="Default constructor. ">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aa844c23eee0a1f388f732477483b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa844c23eee0a1f388f732477483b33">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ad0c874038de46f43becf699c9b8a1b5b">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set properties and hash functor tuple (move semantics) </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a99951f1c472fe6bc40ed35693f4df992">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#ab919ab7745976c25c78f3690ef211a93">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a584d3ced409c754153b585be05a85e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584d3ced409c754153b585be05a85e00">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a id="a17a224c06b767df1f39e5eb7fb3625a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a224c06b767df1f39e5eb7fb3625a5">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set. </p>
<p>The function erases all items from the set. </p>

</div>
</div>
<a id="a667f8c7a6c6759e537f759535e4d1ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667f8c7a6c6759e537f759535e4d1ebb">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a6e7cf932bc8645eb3051f72c519a49a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7cf932bc8645eb3051f72c519a49a6">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a9a4453ff789e62ed077d47d3d6099e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4453ff789e62ed077d47d3d6099e22">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="af4c4d2a9d75e4a261195bb1f13865c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c4d2a9d75e4a261195bb1f13865c0d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>

</div>
</div>
<a id="a600a2a1f6dee844efa7732c9c37fdbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600a2a1f6dee844efa7732c9c37fdbe8">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_erase"></a> Since the key of set's item type <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The set item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="ae087593ff478f76db232f7e6ba664e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae087593ff478f76db232f7e6ba664e2a">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> <span class="keyword">const</span>&amp; val);</div><div class="line">};</div></div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a1cb6ddf92a91d5aa73758d4dd78b03a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb6ddf92a91d5aa73758d4dd78b03a3">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_erase">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. If cuckoo set is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo set is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a0e746d9a12ec6a109364f57383296b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e746d9a12ec6a109364f57383296b9b">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a8bc2faf556b0509b97dc9f45ca0ca814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc2faf556b0509b97dc9f45ca0ca814">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooSet_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a>&amp; item, Q&amp; val );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code>item</code>. The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>The type <code>Q</code> can differ from <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> of items storing in the container. Therefore, the <code>value_type</code> should be comparable with type <code>Q</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a90bf720dc7a1496938965d5c3ae9a090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf720dc7a1496938965d5c3ae9a090">&#9670;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#cds_nonintrusive_CuckooSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a31094d63170ecc65adfba66f838e4736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31094d63170ecc65adfba66f838e4736">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="aabf139c50172cf26e3d94a7c7141c562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf139c50172cf26e3d94a7c7141c562">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of new item .</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a>&amp; item );</div></div><!-- fragment --><p> where <code>item</code> is the item inserted.</p>
<p>The type <code>Q</code> can differ from <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a> of items storing in the set. Therefore, the <code>value_type</code> should be constructible from type <code>Q</code>.</p>
<p>The user-defined functor is called only if the inserting is success. </p>

</div>
</div>
<a id="a508c2899a48d810de6718d50a3ecb562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508c2899a48d810de6718d50a3ecb562">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_cuckoo_set.html">cds::container::CuckooSet</a>&lt; T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> is not found in the set, then <code>val</code> is inserted into the set iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found. The functor <code>func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_cuckoo_set.html#a6960090b98a1b6f318d12a0ded22ecbf">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val );</div><div class="line">};</div></div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>update</code>() function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refer to the same thing.</li>
</ul>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successful, i.e. the node has been inserted or updated, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already exists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/cuckoo_set.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:46:57 by Doxygen 1.8.13</i>
</div>
</body>
</html>
