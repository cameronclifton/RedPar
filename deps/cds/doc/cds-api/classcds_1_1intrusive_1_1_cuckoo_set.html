<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::intrusive::CuckooSet&lt; T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1intrusive_1_1_cuckoo_set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::CuckooSet&lt; T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cuckoo hash set.  
 <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/cuckoo_set.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::intrusive::CuckooSet&lt; T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1intrusive_1_1_cuckoo_set.png" usemap="#cds::intrusive::CuckooSet_3C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::intrusive::CuckooSet_3C_20T_2C_20Traits_20_3E_map" name="cds::intrusive::CuckooSet_3C_20T_2C_20Traits_20_3E_map">
<area href="classcds_1_1container_1_1_cuckoo_set.html" title="Cuckoo hash set. " alt="cds::container::CuckooSet&lt; T, Traits &gt;" shape="rect" coords="0,56,229,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80f3988a87de588e0a2d873592e6da40"><td class="memItemLeft" align="right" valign="top"><a id="a80f3988a87de588e0a2d873592e6da40"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a></td></tr>
<tr class="memdesc:a80f3988a87de588e0a2d873592e6da40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type stored in the set. <br /></td></tr>
<tr class="separator:a80f3988a87de588e0a2d873592e6da40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092995180143580f5c99ee285127c6c9"><td class="memItemLeft" align="right" valign="top"><a id="a092995180143580f5c99ee285127c6c9"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a></td></tr>
<tr class="memdesc:a092995180143580f5c99ee285127c6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br /></td></tr>
<tr class="separator:a092995180143580f5c99ee285127c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282e600d3e6eec649b6237d6834ffc52"><td class="memItemLeft" align="right" valign="top"><a id="a282e600d3e6eec649b6237d6834ffc52"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a></td></tr>
<tr class="memdesc:a282e600d3e6eec649b6237d6834ffc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a282e600d3e6eec649b6237d6834ffc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d55d2a0fff222284b2d978b7a0985d"><td class="memItemLeft" align="right" valign="top"><a id="a11d55d2a0fff222284b2d978b7a0985d"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a></td></tr>
<tr class="memdesc:a11d55d2a0fff222284b2d978b7a0985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:a11d55d2a0fff222284b2d978b7a0985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af0e1eb823a6d2f1c557686c912c605"><td class="memItemLeft" align="right" valign="top"><a id="a9af0e1eb823a6d2f1c557686c912c605"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9af0e1eb823a6d2f1c557686c912c605">node_traits</a></td></tr>
<tr class="memdesc:a9af0e1eb823a6d2f1c557686c912c605"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:a9af0e1eb823a6d2f1c557686c912c605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb19f8057ca1bb84b31722b2d287c4f3"><td class="memItemLeft" align="right" valign="top"><a id="aeb19f8057ca1bb84b31722b2d287c4f3"></a>
typedef traits::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a></td></tr>
<tr class="memdesc:aeb19f8057ca1bb84b31722b2d287c4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br /></td></tr>
<tr class="separator:aeb19f8057ca1bb84b31722b2d287c4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109563a562d2cc52f6819b272923dfa7"><td class="memItemLeft" align="right" valign="top"><a id="a109563a562d2cc52f6819b272923dfa7"></a>
typedef hash::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a></td></tr>
<tr class="memdesc:a109563a562d2cc52f6819b272923dfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br /></td></tr>
<tr class="separator:a109563a562d2cc52f6819b272923dfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44220cb2b6696715e2e902c07a13e330"><td class="memItemLeft" align="right" valign="top"><a id="a44220cb2b6696715e2e902c07a13e330"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a></td></tr>
<tr class="memdesc:a44220cb2b6696715e2e902c07a13e330"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:a44220cb2b6696715e2e902c07a13e330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45ae046c619faae22f2f16f5ba6f6c"><td class="memItemLeft" align="right" valign="top"><a id="a3f45ae046c619faae22f2f16f5ba6f6c"></a>
typedef traits::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3f45ae046c619faae22f2f16f5ba6f6c">original_mutex_policy</a></td></tr>
<tr class="memdesc:a3f45ae046c619faae22f2f16f5ba6f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html#af601783d33a04234fc6fad8d2235b349" title="Concurrent access policy. ">cuckoo::traits::mutex_policy</a></code>. <br /></td></tr>
<tr class="separator:a3f45ae046c619faae22f2f16f5ba6f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7de3b1f961e712b85e967df7e762b4"><td class="memItemLeft" align="right" valign="top"><a id="aef7de3b1f961e712b85e967df7e762b4"></a>
typedef opt::details::make_equal_to&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a>, !<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aef7de3b1f961e712b85e967df7e762b4">key_equal_to</a></td></tr>
<tr class="memdesc:aef7de3b1f961e712b85e967df7e762b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br /></td></tr>
<tr class="separator:aef7de3b1f961e712b85e967df7e762b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6cc0f5f964eaef3a8559c2e0377263"><td class="memItemLeft" align="right" valign="top"><a id="a8c6cc0f5f964eaef3a8559c2e0377263"></a>
typedef opt::details::make_comparator&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8c6cc0f5f964eaef3a8559c2e0377263">key_comparator</a></td></tr>
<tr class="memdesc:a8c6cc0f5f964eaef3a8559c2e0377263"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a></code> and <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a></code> option setter. Used only for ordered probe set <br /></td></tr>
<tr class="separator:a8c6cc0f5f964eaef3a8559c2e0377263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c29caeacd9eab62a8295cb776f65ca7"><td class="memItemLeft" align="right" valign="top"><a id="a1c29caeacd9eab62a8295cb776f65ca7"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1c29caeacd9eab62a8295cb776f65ca7">allocator</a></td></tr>
<tr class="memdesc:a1c29caeacd9eab62a8295cb776f65ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type <br /></td></tr>
<tr class="separator:a1c29caeacd9eab62a8295cb776f65ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4384afbdc9b2688c6175aafd3bbb85a9"><td class="memItemLeft" align="right" valign="top"><a id="a4384afbdc9b2688c6175aafd3bbb85a9"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a4384afbdc9b2688c6175aafd3bbb85a9">item_counter</a></td></tr>
<tr class="memdesc:a4384afbdc9b2688c6175aafd3bbb85a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br /></td></tr>
<tr class="separator:a4384afbdc9b2688c6175aafd3bbb85a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93619c3ddbc8fc96a0b6481de8e03126"><td class="memItemLeft" align="right" valign="top"><a id="a93619c3ddbc8fc96a0b6481de8e03126"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a93619c3ddbc8fc96a0b6481de8e03126">disposer</a></td></tr>
<tr class="memdesc:a93619c3ddbc8fc96a0b6481de8e03126"><td class="mdescLeft">&#160;</td><td class="mdescRight">node disposer <br /></td></tr>
<tr class="separator:a93619c3ddbc8fc96a0b6481de8e03126"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e221ce6294ce2a9bd4ad4e6fe06b367"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a3e221ce6294ce2a9bd4ad4e6fe06b367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3e221ce6294ce2a9bd4ad4e6fe06b367">More...</a><br /></td></tr>
<tr class="separator:a3e221ce6294ce2a9bd4ad4e6fe06b367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f71b08de102c3ca85b9bc53963b38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac18f71b08de102c3ca85b9bc53963b38">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:ac18f71b08de102c3ca85b9bc53963b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="#ac18f71b08de102c3ca85b9bc53963b38">More...</a><br /></td></tr>
<tr class="separator:ac18f71b08de102c3ca85b9bc53963b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cec0e76f68e4d0462420d577c728c76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a2cec0e76f68e4d0462420d577c728c76">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a2cec0e76f68e4d0462420d577c728c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="#a2cec0e76f68e4d0462420d577c728c76">More...</a><br /></td></tr>
<tr class="separator:a2cec0e76f68e4d0462420d577c728c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ecfbae605b0199e0b0b2d15fd3d73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a028ecfbae605b0199e0b0b2d15fd3d73">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a028ecfbae605b0199e0b0b2d15fd3d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="#a028ecfbae605b0199e0b0b2d15fd3d73">More...</a><br /></td></tr>
<tr class="separator:a028ecfbae605b0199e0b0b2d15fd3d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f68f38da3654e56754e08c94f66d2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95f68f38da3654e56754e08c94f66d2e">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a95f68f38da3654e56754e08c94f66d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="#a95f68f38da3654e56754e08c94f66d2e">More...</a><br /></td></tr>
<tr class="separator:a95f68f38da3654e56754e08c94f66d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede715e446da90de4e51b19d64236da3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aede715e446da90de4e51b19d64236da3">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aede715e446da90de4e51b19d64236da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="#aede715e446da90de4e51b19d64236da3">More...</a><br /></td></tr>
<tr class="separator:aede715e446da90de4e51b19d64236da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545595f7caba3bdd3520e16115a7fa2b"><td class="memItemLeft" align="right" valign="top"><a id="a545595f7caba3bdd3520e16115a7fa2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a545595f7caba3bdd3520e16115a7fa2b">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a545595f7caba3bdd3520e16115a7fa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a545595f7caba3bdd3520e16115a7fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75199d012de6ab7c3315dda78b4b3025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a75199d012de6ab7c3315dda78b4b3025">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a75199d012de6ab7c3315dda78b4b3025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a75199d012de6ab7c3315dda78b4b3025">More...</a><br /></td></tr>
<tr class="separator:a75199d012de6ab7c3315dda78b4b3025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a103ae7f5ebd72ac7fe2a1cc751f937bd">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a103ae7f5ebd72ac7fe2a1cc751f937bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a103ae7f5ebd72ac7fe2a1cc751f937bd">More...</a><br /></td></tr>
<tr class="separator:a103ae7f5ebd72ac7fe2a1cc751f937bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341ac3ce1c85b0f84c041132d42ec1a"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a1341ac3ce1c85b0f84c041132d42ec1a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1341ac3ce1c85b0f84c041132d42ec1a">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a1341ac3ce1c85b0f84c041132d42ec1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a1341ac3ce1c85b0f84c041132d42ec1a">More...</a><br /></td></tr>
<tr class="separator:a1341ac3ce1c85b0f84c041132d42ec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2d0ae24a2a32edc066a96e003e9bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44c2d0ae24a2a32edc066a96e003e9bb">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a44c2d0ae24a2a32edc066a96e003e9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="#a44c2d0ae24a2a32edc066a96e003e9bb">More...</a><br /></td></tr>
<tr class="separator:a44c2d0ae24a2a32edc066a96e003e9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9b4514beb5a17fa560faca26c3134e38">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a9b4514beb5a17fa560faca26c3134e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a9b4514beb5a17fa560faca26c3134e38">More...</a><br /></td></tr>
<tr class="separator:a9b4514beb5a17fa560faca26c3134e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a664d70addf3f701f1a62013c69355790">erase_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a664d70addf3f701f1a62013c69355790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a664d70addf3f701f1a62013c69355790">More...</a><br /></td></tr>
<tr class="separator:a664d70addf3f701f1a62013c69355790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a7036d8b2985726d5cb138c879d016a44">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a7036d8b2985726d5cb138c879d016a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set.  <a href="#a7036d8b2985726d5cb138c879d016a44">More...</a><br /></td></tr>
<tr class="separator:a7036d8b2985726d5cb138c879d016a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a213ba3e87c26e5a1afcc84e7cea477ad">erase_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a213ba3e87c26e5a1afcc84e7cea477ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a213ba3e87c26e5a1afcc84e7cea477ad">More...</a><br /></td></tr>
<tr class="separator:a213ba3e87c26e5a1afcc84e7cea477ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a578457cdff461f79ba9e57515d851b71">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a578457cdff461f79ba9e57515d851b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a578457cdff461f79ba9e57515d851b71">More...</a><br /></td></tr>
<tr class="separator:a578457cdff461f79ba9e57515d851b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a783b11c482e9e855ec9d207262aefd75">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a783b11c482e9e855ec9d207262aefd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a783b11c482e9e855ec9d207262aefd75">More...</a><br /></td></tr>
<tr class="separator:a783b11c482e9e855ec9d207262aefd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753b31e6fa9114cd1d95471ee057b6a2"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a753b31e6fa9114cd1d95471ee057b6a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a753b31e6fa9114cd1d95471ee057b6a2">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a753b31e6fa9114cd1d95471ee057b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#a753b31e6fa9114cd1d95471ee057b6a2">More...</a><br /></td></tr>
<tr class="separator:a753b31e6fa9114cd1d95471ee057b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d7acb708e5cfc7488b2d5fb584e6f9"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Predicate &gt; </td></tr>
<tr class="memitem:a10d7acb708e5cfc7488b2d5fb584e6f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a10d7acb708e5cfc7488b2d5fb584e6f9">contains</a> (Q const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a10d7acb708e5cfc7488b2d5fb584e6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a10d7acb708e5cfc7488b2d5fb584e6f9">More...</a><br /></td></tr>
<tr class="separator:a10d7acb708e5cfc7488b2d5fb584e6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc138e7fd59de4e6a8e0ce6fc13b3f20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#adc138e7fd59de4e6a8e0ce6fc13b3f20">clear</a> ()</td></tr>
<tr class="memdesc:adc138e7fd59de4e6a8e0ce6fc13b3f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#adc138e7fd59de4e6a8e0ce6fc13b3f20">More...</a><br /></td></tr>
<tr class="separator:adc138e7fd59de4e6a8e0ce6fc13b3f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee"><td class="memTemplParams" colspan="2">template&lt;typename Disposer &gt; </td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a23148d079b580ccc0a9141094b9534ee">clear_and_dispose</a> (Disposer oDisposer)</td></tr>
<tr class="memdesc:a23148d079b580ccc0a9141094b9534ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="#a23148d079b580ccc0a9141094b9534ee">More...</a><br /></td></tr>
<tr class="separator:a23148d079b580ccc0a9141094b9534ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4054cc5d2d9188e9a1f7dc0457a7018"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad4054cc5d2d9188e9a1f7dc0457a7018">empty</a> () const</td></tr>
<tr class="memdesc:ad4054cc5d2d9188e9a1f7dc0457a7018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#ad4054cc5d2d9188e9a1f7dc0457a7018">More...</a><br /></td></tr>
<tr class="separator:ad4054cc5d2d9188e9a1f7dc0457a7018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dce7a98ed8d4626bb1c2e9672dffc2"><td class="memItemLeft" align="right" valign="top"><a id="a84dce7a98ed8d4626bb1c2e9672dffc2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a84dce7a98ed8d4626bb1c2e9672dffc2">size</a> () const</td></tr>
<tr class="memdesc:a84dce7a98ed8d4626bb1c2e9672dffc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a84dce7a98ed8d4626bb1c2e9672dffc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe99a77d44fc4f1099a9a3c2affc33d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8fe99a77d44fc4f1099a9a3c2affc33d">bucket_count</a> () const</td></tr>
<tr class="memdesc:a8fe99a77d44fc4f1099a9a3c2affc33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a8fe99a77d44fc4f1099a9a3c2affc33d">More...</a><br /></td></tr>
<tr class="separator:a8fe99a77d44fc4f1099a9a3c2affc33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c76acd490b84ce210189b49b7cd1897"><td class="memItemLeft" align="right" valign="top"><a id="a8c76acd490b84ce210189b49b7cd1897"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8c76acd490b84ce210189b49b7cd1897">lock_count</a> () const</td></tr>
<tr class="memdesc:a8c76acd490b84ce210189b49b7cd1897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a8c76acd490b84ce210189b49b7cd1897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c315c3c0639fdc8f6eb95ec9c2de1"><td class="memItemLeft" align="right" valign="top"><a id="abd0c315c3c0639fdc8f6eb95ec9c2de1"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#abd0c315c3c0639fdc8f6eb95ec9c2de1">statistics</a> () const</td></tr>
<tr class="memdesc:abd0c315c3c0639fdc8f6eb95ec9c2de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:abd0c315c3c0639fdc8f6eb95ec9c2de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846653e92450dfb38d9a217b1405ee3"><td class="memItemLeft" align="right" valign="top"><a id="ae846653e92450dfb38d9a217b1405ee3"></a>
mutex_policy::statistics_type const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ae846653e92450dfb38d9a217b1405ee3">mutex_policy_statistics</a> () const</td></tr>
<tr class="memdesc:ae846653e92450dfb38d9a217b1405ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br /></td></tr>
<tr class="separator:ae846653e92450dfb38d9a217b1405ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aec91125eaafeba9da642a4ec74fd7c0f"><td class="memItemLeft" align="right" valign="top">static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a></td></tr>
<tr class="memdesc:aec91125eaafeba9da642a4ec74fd7c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set should be ordered or not.  <a href="#aec91125eaafeba9da642a4ec74fd7c0f">More...</a><br /></td></tr>
<tr class="separator:aec91125eaafeba9da642a4ec74fd7c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57c3ed1e36757238a5396a667eeb06f"><td class="memItemLeft" align="right" valign="top"><a id="af57c3ed1e36757238a5396a667eeb06f"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> = hash::size</td></tr>
<tr class="memdesc:af57c3ed1e36757238a5396a667eeb06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br /></td></tr>
<tr class="separator:af57c3ed1e36757238a5396a667eeb06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7428e959608e5decac221dc317e8da8"><td class="memItemLeft" align="right" valign="top"><a id="aa7428e959608e5decac221dc317e8da8"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa7428e959608e5decac221dc317e8da8">c_nDefaultProbesetSize</a> = 4</td></tr>
<tr class="memdesc:aa7428e959608e5decac221dc317e8da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br /></td></tr>
<tr class="separator:aa7428e959608e5decac221dc317e8da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3b066d9b88fd5ec69263a5783ac17"><td class="memItemLeft" align="right" valign="top"><a id="a49f3b066d9b88fd5ec69263a5783ac17"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a49f3b066d9b88fd5ec69263a5783ac17">c_nDefaultInitialSize</a> = 16</td></tr>
<tr class="memdesc:a49f3b066d9b88fd5ec69263a5783ac17"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br /></td></tr>
<tr class="separator:a49f3b066d9b88fd5ec69263a5783ac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb27b2754ff51b10ee5e7754aafec36"><td class="memItemLeft" align="right" valign="top"><a id="aceb27b2754ff51b10ee5e7754aafec36"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aceb27b2754ff51b10ee5e7754aafec36">c_nRelocateLimit</a> = <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> * 2 - 1</td></tr>
<tr class="memdesc:aceb27b2754ff51b10ee5e7754aafec36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br /></td></tr>
<tr class="separator:aceb27b2754ff51b10ee5e7754aafec36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a904af372de54c256d49de92ba849814d"><td class="memItemLeft" align="right" valign="top"><a id="a904af372de54c256d49de92ba849814d"></a>
bucket_entry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a904af372de54c256d49de92ba849814d">m_BucketTable</a> [<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a>]</td></tr>
<tr class="memdesc:a904af372de54c256d49de92ba849814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket tables. <br /></td></tr>
<tr class="separator:a904af372de54c256d49de92ba849814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df0bbf3e71dbb842c2210122593fdf"><td class="memItemLeft" align="right" valign="top"><a id="a86df0bbf3e71dbb842c2210122593fdf"></a>
atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a86df0bbf3e71dbb842c2210122593fdf">m_nBucketMask</a></td></tr>
<tr class="memdesc:a86df0bbf3e71dbb842c2210122593fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash bitmask; bucket table size minus 1. <br /></td></tr>
<tr class="separator:a86df0bbf3e71dbb842c2210122593fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96855242b5e8df7673689fce275e6410"><td class="memItemLeft" align="right" valign="top"><a id="a96855242b5e8df7673689fce275e6410"></a>
unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a96855242b5e8df7673689fce275e6410">m_nProbesetSize</a></td></tr>
<tr class="memdesc:a96855242b5e8df7673689fce275e6410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set size. <br /></td></tr>
<tr class="separator:a96855242b5e8df7673689fce275e6410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a50b187e648a3855129792ba90ed05"><td class="memItemLeft" align="right" valign="top"><a id="a80a50b187e648a3855129792ba90ed05"></a>
unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80a50b187e648a3855129792ba90ed05">m_nProbesetThreshold</a></td></tr>
<tr class="memdesc:a80a50b187e648a3855129792ba90ed05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set threshold. <br /></td></tr>
<tr class="separator:a80a50b187e648a3855129792ba90ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c17058bb63f1b7b32e174642b2d0a31"><td class="memItemLeft" align="right" valign="top"><a id="a6c17058bb63f1b7b32e174642b2d0a31"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a6c17058bb63f1b7b32e174642b2d0a31">m_Hash</a></td></tr>
<tr class="memdesc:a6c17058bb63f1b7b32e174642b2d0a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor tuple. <br /></td></tr>
<tr class="separator:a6c17058bb63f1b7b32e174642b2d0a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b55f3a0eb6ad233feee8b9917abaa4"><td class="memItemLeft" align="right" valign="top"><a id="aa3b55f3a0eb6ad233feee8b9917abaa4"></a>
mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa3b55f3a0eb6ad233feee8b9917abaa4">m_MutexPolicy</a></td></tr>
<tr class="memdesc:aa3b55f3a0eb6ad233feee8b9917abaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">concurrent access policy <br /></td></tr>
<tr class="separator:aa3b55f3a0eb6ad233feee8b9917abaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a84f7b7af5ed6cb9f18ff528d41aae2"><td class="memItemLeft" align="right" valign="top"><a id="a8a84f7b7af5ed6cb9f18ff528d41aae2"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a4384afbdc9b2688c6175aafd3bbb85a9">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8a84f7b7af5ed6cb9f18ff528d41aae2">m_ItemCounter</a></td></tr>
<tr class="memdesc:a8a84f7b7af5ed6cb9f18ff528d41aae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br /></td></tr>
<tr class="separator:a8a84f7b7af5ed6cb9f18ff528d41aae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac364bc421fc0fe5cce1ed31d99faa74a"><td class="memItemLeft" align="right" valign="top"><a id="ac364bc421fc0fe5cce1ed31d99faa74a"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac364bc421fc0fe5cce1ed31d99faa74a">m_Stat</a></td></tr>
<tr class="memdesc:ac364bc421fc0fe5cce1ed31d99faa74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:ac364bc421fc0fe5cce1ed31d99faa74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Traits = cuckoo::traits&gt;<br />
class cds::intrusive::CuckooSet&lt; T, Traits &gt;</h3>

<p>Cuckoo hash set. </p>
<p>Source</p><ul>
<li>[2007] M.Herlihy, N.Shavit, M.Tzafrir "Concurrent Cuckoo Hashing. Technical report"</li>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p><b>About Cuckoo hashing</b></p>
<p>[From <em>"The Art of Multiprocessor Programming"</em>] <a href="https://en.wikipedia.org/wiki/Cuckoo_hashing">Cuckoo hashing</a> is a hashing algorithm in which a newly added item displaces any earlier item occupying the same slot. For brevity, a table is a k-entry array of items. For a hash set of size N = 2k we use a two-entry array of tables, and two independent hash functions, <code> h0, h1: KeyRange -&gt; 0,...,k-1</code> mapping the set of possible keys to entries in he array. To test whether a value <code>x</code> is in the set, <code>find(x)</code> tests whether either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code> is equal to <code>x</code>. Similarly, <code>erase(x)</code>checks whether <code>x</code> is in either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code>, ad removes it if found.</p>
<p>The <code>insert(x)</code> successively "kicks out" conflicting items until every key has a slot. To add <code>x</code>, the method swaps <code>x</code> with <code>y</code>, the current occupant of <code>table[0][h0(x)]</code>. If the prior value was <code>nullptr</code>, it is done. Otherwise, it swaps the newly nest-less value <code>y</code> for the current occupant of <code>table[1][h1(y)]</code> in the same way. As before, if the prior value was <code>nullptr</code>, it is done. Otherwise, the method continues swapping entries (alternating tables) until it finds an empty slot. We might not find an empty slot, either because the table is full, or because the sequence of displacement forms a cycle. We therefore need an upper limit on the number of successive displacements we are willing to undertake. When this limit is exceeded, we resize the hash table, choose new hash functions and start over.</p>
<p>For concurrent cuckoo hashing, rather than organizing the set as a two-dimensional table of items, we use two-dimensional table of probe sets, where a probe set is a constant-sized set of items with the same hash code. Each probe set holds at most <code>PROBE_SIZE</code> items, but the algorithm tries to ensure that when the set is quiescent (i.e no method call in progress) each probe set holds no more than <code>THRESHOLD &lt; PROBE_SET</code> items. While method calls are in-flight, a probe set may temporarily hold more than <code>THRESHOLD</code> but never more than <code>PROBE_SET</code> items.</p>
<p>In current implementation, a probe set can be defined either as a (single-linked) list or as a fixed-sized vector, optionally ordered.</p>
<p>In description above two-table cuckoo hashing (<code>k = 2</code>) has been considered. We can generalize this approach for <code>k &gt;= 2</code> when we have <code>k</code> hash functions <code>h[0], ... h[k-1]</code> and <code>k</code> tables <code>table[0], ... table[k-1]</code>.</p>
<p>The search in probe set is linear, the complexity is <code> O(PROBE_SET) </code>. The probe set may be ordered or not. Ordered probe set can be more efficient since the average search complexity is <code>O(PROBE_SET/2)</code>. However, the overhead of sorting can eliminate a gain of ordered search.</p>
<p>The probe set is ordered if <code>compare</code> or <code>less</code> is specified in <code>Traits</code> template parameter. Otherwise, the probe set is unordered and <code>Traits</code> should provide <code>equal_to</code> predicate.</p>
<p>The <code><a class="el" href="namespacecds_1_1intrusive_1_1cuckoo.html" title="CuckooSet-related definitions. ">cds::intrusive::cuckoo</a></code> namespace contains <code>CuckooSet-related</code> declarations.</p>
<p>Template arguments:</p><ul>
<li><code>T</code> - the type stored in the set. The type must be based on <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1node.html" title="CuckooSet node. ">cuckoo::node</a></code> (for <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1base__hook.html" title="Base hook. ">cuckoo::base_hook</a></code>) or it must have a member of type cuckoo::node (for <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1member__hook.html" title="Member hook. ">cuckoo::member_hook</a></code>), or it must be convertible to <code>cuckoo::node</code> (for <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1traits__hook.html" title="Traits hook. ">cuckoo::traits_hook</a></code>)</li>
<li><code>Traits</code> - type traits, default is <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html" title="Type traits for CuckooSet class. ">cuckoo::traits</a></code>. It is possible to declare option-based set with <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet traits. ">cuckoo::make_traits</a></code> metafunction result as <code>Traits</code> template argument.</li>
</ul>
<p><b>How to use</b></p>
<p>You should incorporate <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1node.html" title="CuckooSet node. ">cuckoo::node</a></code> into your struct <code>T</code> and provide appropriate <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html#a88256a582eb7f27a15dd78429ab3fbc9" title="Hook used. ">cuckoo::traits::hook</a></code> in your <code>Traits</code> template parameters. Usually, for <code>Traits</code> you define a struct based on <code><a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html" title="Type traits for CuckooSet class. ">cuckoo::traits</a></code>.</p>
<p>Example for base hook and list-based probe-set: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/cuckoo_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Data stored in cuckoo set</span></div><div class="line"><span class="comment">// We use list as probe-set container and store hash values in the node</span></div><div class="line"><span class="comment">// (since we use two hash functions we should store 2 hash values per node)</span></div><div class="line"><span class="keyword">struct </span>my_data: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1node.html">cds::intrusive::cuckoo::node</a>&lt; cds::intrusive::cuckoo::list, 2 &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// key field</span></div><div class="line">    std::string     strKey;</div><div class="line"></div><div class="line">    <span class="comment">// other data</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide equal_to functor for my_data since we will use unordered probe-set</span></div><div class="line"><span class="keyword">struct </span>my_data_equal_to {</div><div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey ) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey ) == 0;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide two hash functor for my_data</span></div><div class="line"><span class="keyword">struct </span>hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s );</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s));</div><div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare type traits</span></div><div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html">cds::intrusive::cuckoo::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1base__hook.html">cds::intrusive::cuckoo::base_hook</a>&lt;</div><div class="line">        <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1probeset__type.html">cds::intrusive::cuckoo::probeset_type&lt; my_data::probeset_type &gt;</a></div><div class="line">        ,<a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1store__hash.html">cds::intrusive::cuckoo::store_hash&lt; my_data::hash_array_size &gt;</a></div><div class="line">    &gt;   <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a>;</div><div class="line">    <span class="keyword">typedef</span> my_data_equa_to equal_to;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="namespacecds_1_1opt.html#a1199952408a76c79921776f69e7a5754">cds::opt::hash_tuple&lt; hash1, hash2 &gt;</a> <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare CuckooSet type</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; my_data, my_traits &gt;</a> my_cuckoo_set;</div><div class="line"></div><div class="line"><span class="comment">// Equal option-based declaration</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; my_data,</div><div class="line">    <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1make__traits.html">cds::intrusive::cuckoo::make_traits</a>&lt;</div><div class="line">        <a class="code" href="structcds_1_1intrusive_1_1opt_1_1hook.html">cds::intrusive::opt::hook</a>&lt; <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1base__hook.html">cds::intrusive::cuckoo::base_hook</a>&lt;</div><div class="line">            <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1probeset__type.html">cds::intrusive::cuckoo::probeset_type&lt; my_data::probeset_type &gt;</a></div><div class="line">            ,<a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1store__hash.html">cds::intrusive::cuckoo::store_hash&lt; my_data::hash_array_size &gt;</a></div><div class="line">        &gt; &gt;</div><div class="line">        ,cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt; &gt;</div><div class="line">        ,cds::opt::equal_to&lt; my_data_equal_to &gt;</div><div class="line">    &gt;::type</div><div class="line">&gt; opt_cuckoo_set;</div></div><!-- fragment --><p>If we provide <code>compare</code> function instead of <code>equal_to</code> for <code>my_data</code> we get as a result a cuckoo set with ordered probe set that may improve performance. Example for base hook and ordered vector-based probe-set:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/cuckoo_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Data stored in cuckoo set</span></div><div class="line"><span class="comment">// We use a vector of capacity 4 as probe-set container and store hash values in the node</span></div><div class="line"><span class="comment">// (since we use two hash functions we should store 2 hash values per node)</span></div><div class="line"><span class="keyword">struct </span>my_data: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1node.html">cds::intrusive::cuckoo::node</a>&lt; cds::intrusive::cuckoo::vector&lt;4&gt;, 2 &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// key field</span></div><div class="line">    std::string     strKey;</div><div class="line"></div><div class="line">    <span class="comment">// other data</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide compare functor for my_data since we want to use ordered probe-set</span></div><div class="line"><span class="keyword">struct </span>my_data_compare {</div><div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d1, <span class="keyword">const</span> my_data&amp; d2 )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d1.strKey.compare( d2.strKey );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> my_data&amp; d, <span class="keyword">const</span> std::string&amp; s )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> d.strKey.compare(s);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> operator()( <span class="keyword">const</span> std::string&amp; s, <span class="keyword">const</span> my_data&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> s.compare( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Provide two hash functor for my_data</span></div><div class="line"><span class="keyword">struct </span>hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s );</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div><div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s));</div><div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">size_t</span> operator()( my_data <span class="keyword">const</span>&amp; d )<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> (*<span class="keyword">this</span>)( d.strKey );</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare type traits</span></div><div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1traits.html">cds::intrusive::cuckoo::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1base__hook.html">cds::intrusive::cuckoo::base_hook</a>&lt;</div><div class="line">        cds::intrusive::cuckoo::probeset_type&lt; my_data::probeset_type &gt;</div><div class="line">        ,cds::intrusive::cuckoo::store_hash&lt; my_data::hash_array_size &gt;</div><div class="line">    &gt;   <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a>;</div><div class="line">    <span class="keyword">typedef</span> my_data_compare compare;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="namespacecds_1_1opt.html#a1199952408a76c79921776f69e7a5754">cds::opt::hash_tuple&lt; hash1, hash2 &gt;</a> <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare CuckooSet type</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; my_data, my_traits &gt;</a> my_cuckoo_set;</div><div class="line"></div><div class="line"><span class="comment">// Equal option-based declaration</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; my_data,</div><div class="line">    <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1make__traits.html">cds::intrusive::cuckoo::make_traits</a>&lt;</div><div class="line">        <a class="code" href="structcds_1_1intrusive_1_1opt_1_1hook.html">cds::intrusive::opt::hook</a>&lt; <a class="code" href="structcds_1_1intrusive_1_1cuckoo_1_1base__hook.html">cds::intrusive::cuckoo::base_hook</a>&lt;</div><div class="line">            cds::intrusive::cuckoo::probeset_type&lt; my_data::probeset_type &gt;</div><div class="line">            ,cds::intrusive::cuckoo::store_hash&lt; my_data::hash_array_size &gt;</div><div class="line">        &gt; &gt;</div><div class="line">        ,cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt; &gt;</div><div class="line">        ,cds::opt::compare&lt; my_data_compare &gt;</div><div class="line">    &gt;::type</div><div class="line">&gt; opt_cuckoo_set;</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e221ce6294ce2a9bd4ad4e6fe06b367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e221ce6294ce2a9bd4ad4e6fe06b367">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initial size = <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a49f3b066d9b88fd5ec69263a5783ac17">c_nDefaultInitialSize</a></p>
<p>Probe set size:</p><ul>
<li><code>c_nDefaultProbesetSize</code> if <code>probeset_type</code> is <code>cuckoo::list</code> </li>
<li><code>Capacity</code> if <code>probeset_type</code> is <code> cuckoo::vector&lt;Capacity&gt; </code></li>
</ul>
<p>Probe set threshold = probe set size - 1 </p>

</div>
</div>
<a id="ac18f71b08de102c3ca85b9bc53963b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18f71b08de102c3ca85b9bc53963b38">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set size and threshold. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> is ignored since it should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <code>c_nDefaultInitialSize</code> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, <code>nProbesetThreshold = nProbesetSize - 1</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cec0e76f68e4d0462420d577c728c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cec0e76f68e4d0462420d577c728c76">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given hash functor tuple. </p>
<p>The probe set size and threshold are set as default, see <code><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367" title="Default constructor. ">CuckooSet()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a028ecfbae605b0199e0b0b2d15fd3d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ecfbae605b0199e0b0b2d15fd3d73">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set properties and hash functor tuple. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <code>c_nDefaultInitialSize</code> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size, positive integer </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, <code>nProbesetThreshold = nProbesetSize - 1</code> </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f68f38da3654e56754e08c94f66d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f68f38da3654e56754e08c94f66d2e">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given hash functor tuple (move semantics) </p>
<p>The probe set size and threshold are set as default, see <code><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367" title="Default constructor. ">CuckooSet()</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aede715e446da90de4e51b19d64236da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede715e446da90de4e51b19d64236da3">&#9670;&nbsp;</a></span>CuckooSet() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the set object with given probe set properties and hash functor tuple (move semantics) </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial set size; if 0 - use default initial size <code>c_nDefaultInitialSize</code> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size, positive integer </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, <code>nProbesetThreshold = nProbesetSize - 1</code> </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8fe99a77d44fc4f1099a9a3c2affc33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe99a77d44fc4f1099a9a3c2affc33d">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a id="adc138e7fd59de4e6a8e0ce6fc13b3f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc138e7fd59de4e6a8e0ce6fc13b3f20">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set. </p>
<p>The function unlinks all items from the set. For any item <code>Traits::disposer</code> is called </p>

</div>
</div>
<a id="a23148d079b580ccc0a9141094b9534ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23148d079b580ccc0a9141094b9534ee">&#9670;&nbsp;</a></span>clear_and_dispose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Disposer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::clear_and_dispose </td>
          <td>(</td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"><em>oDisposer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set and calls <code>disposer</code> for each item. </p>
<p>The function unlinks all items from the set calling <code>oDisposer</code> for each item. <code>Disposer</code> functor interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Disposer{</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> * p );</div><div class="line">};</div></div><!-- fragment --><p>The <code>Traits::disposer</code> is not called. </p>

</div>
</div>
<a id="a753b31e6fa9114cd1d95471ee057b6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753b31e6fa9114cd1d95471ee057b6a2">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a10d7acb708e5cfc7488b2d5fb584e6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d7acb708e5cfc7488b2d5fb584e6f9">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. If the set is unordered, <code>Predicate</code> has semantics like <code>std::equal_to</code>. For ordered set <code>Predicate</code> has <code>std::less</code> semantics. In that case <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="ad4054cc5d2d9188e9a1f7dc0457a7018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4054cc5d2d9188e9a1f7dc0457a7018">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>

</div>
</div>
<a id="a9b4514beb5a17fa560faca26c3134e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4514beb5a17fa560faca26c3134e38">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p><a class="anchor" id="cds_intrusive_CuckooSet_erase"></a>The function searches an item with key equal to <code>val</code> in the set, unlinks it from the set, and returns a pointer to unlinked item.</p>
<p>If the item with key equal to <code>val</code> is not found the function return <code>nullptr</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a id="a7036d8b2985726d5cb138c879d016a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7036d8b2985726d5cb138c879d016a44">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the item from the set. </p>
<p><a class="anchor" id="cds_intrusive_CuckooSet_erase_func"></a>The function searches an item with key equal to <code>val</code> in the set, call <code>f</code> functor with item found, unlinks it from the set, and returns a pointer to unlinked item.</p>
<p>The <code>Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> <span class="keyword">const</span>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>If the item with key equal to <code>val</code> is not found the function return <code>nullptr</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a id="a664d70addf3f701f1a62013c69355790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664d70addf3f701f1a62013c69355790">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#cds_intrusive_CuckooSet_erase">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. If cuckoo set is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo set is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a213ba3e87c26e5a1afcc84e7cea477ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213ba3e87c26e5a1afcc84e7cea477ad">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#cds_intrusive_CuckooSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a578457cdff461f79ba9e57515d851b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578457cdff461f79ba9e57515d851b71">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_intrusive_CuckooSet_find_func"></a>The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>&amp; item, Q&amp; val );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor may modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a783b11c482e9e855ec9d207262aefd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783b11c482e9e855ec9d207262aefd75">&#9670;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#cds_intrusive_CuckooSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo set, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a75199d012de6ab7c3315dda78b4b3025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75199d012de6ab7c3315dda78b4b3025">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the set if it does not contain an item with key equal to <code>val</code>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a103ae7f5ebd72ac7fe2a1cc751f937bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103ae7f5ebd72ac7fe2a1cc751f937bd">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>&amp; val );</div></div><!-- fragment --><p> where <code>val</code> is the item inserted.</p>
<p>The user-defined functor is called only if the inserting is success. </p>

</div>
</div>
<a id="a44c2d0ae24a2a32edc066a96e003e9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c2d0ae24a2a32edc066a96e003e9bb">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink the item <code>val</code> from the set. </p>
<p>The function searches the item <code>val</code> in the set and unlink it if it is found and is equal to <code>val</code> (here, the equality means that <code>val</code> belongs to the set: if <code>item</code> is an item found then unlink is successful iif <code>&amp;val == &amp;item</code>)</p>
<p>The function returns <code>true</code> if success and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a1341ac3ce1c85b0f84c041132d42ec1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1341ac3ce1c85b0f84c041132d42ec1a">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> is not found in the set, then <code>val</code> is inserted into the set iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found. The functor <code>func</code> signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>&amp; item, <a class="code" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>&amp; val );</div></div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>update</code>() function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refer to the same thing.</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successful, i.e. the node has been inserted or updated, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already exists. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="aec91125eaafeba9da642a4ec74fd7c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec91125eaafeba9da642a4ec74fd7c0f">&#9670;&nbsp;</a></span>c_isSorted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool const <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet</a>&lt; T, Traits &gt;::c_isSorted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= !( std::is_same&lt; typename traits::compare, opt::none &gt;::value</div><div class="line">                &amp;&amp; std::is_same&lt; typename traits::less, opt::none &gt;::value )</div></div><!-- fragment -->
<p>Probe set should be ordered or not. </p>
<p>If <code>Traits</code> specifies <code>cmpare</code> or <code>less</code> functor then the set is ordered. Otherwise, it is unordered and <code>Traits</code> should provide <code>equal_to</code> functor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/cuckoo_set.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:47:19 by Doxygen 1.8.13</i>
</div>
</body>
</html>
