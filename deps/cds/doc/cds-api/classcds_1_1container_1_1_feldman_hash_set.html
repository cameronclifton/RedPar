<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::FeldmanHashSet&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_feldman_hash_set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::FeldmanHashSet&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__set.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Hash set based on multi-level array.  
 <a href="classcds_1_1container_1_1_feldman_hash_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/impl/feldman_hashset.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::FeldmanHashSet&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_feldman_hash_set.png" usemap="#cds::container::FeldmanHashSet_3C_20GC_2C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::FeldmanHashSet_3C_20GC_2C_20T_2C_20Traits_20_3E_map" name="cds::container::FeldmanHashSet_3C_20GC_2C_20T_2C_20Traits_20_3E_map">
<area href="classcds_1_1intrusive_1_1_feldman_hash_set.html" title="Intrusive hash set based on multi-level array. " alt="cds::intrusive::FeldmanHashSet&lt; GC, T, Traits &gt;" shape="rect" coords="0,56,290,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acadbdd9d7a55a70a1e9d11f11e18c1a8"><td class="memItemLeft" align="right" valign="top"><a id="acadbdd9d7a55a70a1e9d11f11e18c1a8"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#acadbdd9d7a55a70a1e9d11f11e18c1a8">gc</a></td></tr>
<tr class="memdesc:acadbdd9d7a55a70a1e9d11f11e18c1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:acadbdd9d7a55a70a1e9d11f11e18c1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e2fdcc6c4667962c5bf233493b19fe"><td class="memItemLeft" align="right" valign="top"><a id="ac9e2fdcc6c4667962c5bf233493b19fe"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a></td></tr>
<tr class="memdesc:ac9e2fdcc6c4667962c5bf233493b19fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the set <br /></td></tr>
<tr class="separator:ac9e2fdcc6c4667962c5bf233493b19fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acada1ac72b26368aea612b72969146b9"><td class="memItemLeft" align="right" valign="top"><a id="acada1ac72b26368aea612b72969146b9"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#acada1ac72b26368aea612b72969146b9">traits</a></td></tr>
<tr class="memdesc:acada1ac72b26368aea612b72969146b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter, see <code><a class="el" href="structcds_1_1container_1_1feldman__hashset_1_1traits.html" title="FeldmanHashSet traits ">feldman_hashset::traits</a></code>. <br /></td></tr>
<tr class="separator:acada1ac72b26368aea612b72969146b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc4284f7b7302bc41f8b6b9da05db4"><td class="memItemLeft" align="right" valign="top"><a id="a20cc4284f7b7302bc41f8b6b9da05db4"></a>
typedef base_class::hash_accessor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a20cc4284f7b7302bc41f8b6b9da05db4">hash_accessor</a></td></tr>
<tr class="memdesc:a20cc4284f7b7302bc41f8b6b9da05db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash accessor functor. <br /></td></tr>
<tr class="separator:a20cc4284f7b7302bc41f8b6b9da05db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549898310828bd413825288f14427468"><td class="memItemLeft" align="right" valign="top"><a id="a549898310828bd413825288f14427468"></a>
typedef base_class::hash_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a></td></tr>
<tr class="memdesc:a549898310828bd413825288f14427468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash type deduced from <code>hash_accessor</code> return type. <br /></td></tr>
<tr class="separator:a549898310828bd413825288f14427468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e1ee5573eeccc640a31444400c099b"><td class="memItemLeft" align="right" valign="top"><a id="a70e1ee5573eeccc640a31444400c099b"></a>
typedef base_class::hash_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a70e1ee5573eeccc640a31444400c099b">hash_comparator</a></td></tr>
<tr class="memdesc:a70e1ee5573eeccc640a31444400c099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash compare functor based on <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a></code> and <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a></code> option setter <br /></td></tr>
<tr class="separator:a70e1ee5573eeccc640a31444400c099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4539c6f4b0e7a5d942dac89faf2dd8"><td class="memItemLeft" align="right" valign="top"><a id="a1d4539c6f4b0e7a5d942dac89faf2dd8"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a1d4539c6f4b0e7a5d942dac89faf2dd8">item_counter</a></td></tr>
<tr class="memdesc:a1d4539c6f4b0e7a5d942dac89faf2dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a1d4539c6f4b0e7a5d942dac89faf2dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f03d2cca1b14089297c08eac16108e"><td class="memItemLeft" align="right" valign="top"><a id="af0f03d2cca1b14089297c08eac16108e"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af0f03d2cca1b14089297c08eac16108e">allocator</a></td></tr>
<tr class="memdesc:af0f03d2cca1b14089297c08eac16108e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element allocator. <br /></td></tr>
<tr class="separator:af0f03d2cca1b14089297c08eac16108e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d63371803e8ce5d79fbd0228d388dc1"><td class="memItemLeft" align="right" valign="top"><a id="a3d63371803e8ce5d79fbd0228d388dc1"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a3d63371803e8ce5d79fbd0228d388dc1">node_allocator</a></td></tr>
<tr class="memdesc:a3d63371803e8ce5d79fbd0228d388dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array node allocator. <br /></td></tr>
<tr class="separator:a3d63371803e8ce5d79fbd0228d388dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5001bedb9b15a868a455c312e53745a7"><td class="memItemLeft" align="right" valign="top"><a id="a5001bedb9b15a868a455c312e53745a7"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a5001bedb9b15a868a455c312e53745a7">memory_model</a></td></tr>
<tr class="memdesc:a5001bedb9b15a868a455c312e53745a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory model. <br /></td></tr>
<tr class="separator:a5001bedb9b15a868a455c312e53745a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39acb28b98b893451d2e880501d8ad1"><td class="memItemLeft" align="right" valign="top"><a id="ac39acb28b98b893451d2e880501d8ad1"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac39acb28b98b893451d2e880501d8ad1">back_off</a></td></tr>
<tr class="memdesc:ac39acb28b98b893451d2e880501d8ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backoff strategy. <br /></td></tr>
<tr class="separator:ac39acb28b98b893451d2e880501d8ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f15419e374ab40181e1aca8706f913"><td class="memItemLeft" align="right" valign="top"><a id="a82f15419e374ab40181e1aca8706f913"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a82f15419e374ab40181e1aca8706f913">stat</a></td></tr>
<tr class="memdesc:a82f15419e374ab40181e1aca8706f913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics type. <br /></td></tr>
<tr class="separator:a82f15419e374ab40181e1aca8706f913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28813a91b3e98f2e4799a93ee1d7a3c"><td class="memItemLeft" align="right" valign="top"><a id="ac28813a91b3e98f2e4799a93ee1d7a3c"></a>
typedef gc::template <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a></td></tr>
<tr class="memdesc:ac28813a91b3e98f2e4799a93ee1d7a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:ac28813a91b3e98f2e4799a93ee1d7a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d44a1e4d72a22b899c45ad1ab851d6"><td class="memItemLeft" align="right" valign="top"><a id="a21d44a1e4d72a22b899c45ad1ab851d6"></a>
typedef <a class="el" href="namespacecds_1_1container_1_1feldman__hashset.html#a53ccc7bd7719d07a866a4cbcc78e9f1e">feldman_hashset::level_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a21d44a1e4d72a22b899c45ad1ab851d6">level_statistics</a></td></tr>
<tr class="memdesc:a21d44a1e4d72a22b899c45ad1ab851d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level statistics. <br /></td></tr>
<tr class="separator:a21d44a1e4d72a22b899c45ad1ab851d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aedea0487f262e14f634afb8c362f54fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#aedea0487f262e14f634afb8c362f54fb">FeldmanHashSet</a> (size_t head_bits=8, size_t array_bits=4)</td></tr>
<tr class="memdesc:aedea0487f262e14f634afb8c362f54fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty set.  <a href="#aedea0487f262e14f634afb8c362f54fb">More...</a><br /></td></tr>
<tr class="separator:aedea0487f262e14f634afb8c362f54fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ae69024f5e651ac4846705f45b671"><td class="memItemLeft" align="right" valign="top"><a id="a175ae69024f5e651ac4846705f45b671"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a175ae69024f5e651ac4846705f45b671">~FeldmanHashSet</a> ()</td></tr>
<tr class="memdesc:a175ae69024f5e651ac4846705f45b671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the set and frees all data. <br /></td></tr>
<tr class="separator:a175ae69024f5e651ac4846705f45b671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278d92869523f6e94066ee585e4ec47a"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a278d92869523f6e94066ee585e4ec47a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a278d92869523f6e94066ee585e4ec47a">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a278d92869523f6e94066ee585e4ec47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element.  <a href="#a278d92869523f6e94066ee585e4ec47a">More...</a><br /></td></tr>
<tr class="separator:a278d92869523f6e94066ee585e4ec47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a22e47e36a7c6a1f0bd60fa41aaff1b"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0a22e47e36a7c6a1f0bd60fa41aaff1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0a22e47e36a7c6a1f0bd60fa41aaff1b">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a0a22e47e36a7c6a1f0bd60fa41aaff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element.  <a href="#a0a22e47e36a7c6a1f0bd60fa41aaff1b">More...</a><br /></td></tr>
<tr class="separator:a0a22e47e36a7c6a1f0bd60fa41aaff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d8531e651ab83ce53451cc5034664"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:add7d8531e651ab83ce53451cc5034664"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#add7d8531e651ab83ce53451cc5034664">update</a> (Q const &amp;val, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:add7d8531e651ab83ce53451cc5034664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the element.  <a href="#add7d8531e651ab83ce53451cc5034664">More...</a><br /></td></tr>
<tr class="separator:add7d8531e651ab83ce53451cc5034664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9164538d39bbca5999658158ca344b65"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9164538d39bbca5999658158ca344b65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a9164538d39bbca5999658158ca344b65">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9164538d39bbca5999658158ca344b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> created in-place from <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a9164538d39bbca5999658158ca344b65">More...</a><br /></td></tr>
<tr class="separator:a9164538d39bbca5999658158ca344b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1c4e9f3d8cea14c0823c8a1f83589d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a7e1c4e9f3d8cea14c0823c8a1f83589d">erase</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a7e1c4e9f3d8cea14c0823c8a1f83589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a7e1c4e9f3d8cea14c0823c8a1f83589d">More...</a><br /></td></tr>
<tr class="separator:a7e1c4e9f3d8cea14c0823c8a1f83589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635a611a3710eefc545c293eab65f1bf"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a635a611a3710eefc545c293eab65f1bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a635a611a3710eefc545c293eab65f1bf">erase</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;hash, Func f)</td></tr>
<tr class="memdesc:a635a611a3710eefc545c293eab65f1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a635a611a3710eefc545c293eab65f1bf">More...</a><br /></td></tr>
<tr class="separator:a635a611a3710eefc545c293eab65f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaafb57182d7e59ae52471a5acab612"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#afaaafb57182d7e59ae52471a5acab612">erase_at</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af90583bd4b540dec1175ca03d5263cf5">iterator</a> const &amp;iter)</td></tr>
<tr class="memdesc:afaaafb57182d7e59ae52471a5acab612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item pointed by iterator <code>iter</code>.  <a href="#afaaafb57182d7e59ae52471a5acab612">More...</a><br /></td></tr>
<tr class="separator:afaaafb57182d7e59ae52471a5acab612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c63a14b6e2bc8b5b48224f3472f469c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a1c63a14b6e2bc8b5b48224f3472f469c">extract</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a1c63a14b6e2bc8b5b48224f3472f469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>hash</code>.  <a href="#a1c63a14b6e2bc8b5b48224f3472f469c">More...</a><br /></td></tr>
<tr class="separator:a1c63a14b6e2bc8b5b48224f3472f469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97b736120f0a40aaa2528eac5eee9c2"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ae97b736120f0a40aaa2528eac5eee9c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ae97b736120f0a40aaa2528eac5eee9c2">find</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;hash, Func f)</td></tr>
<tr class="memdesc:ae97b736120f0a40aaa2528eac5eee9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an item by it's <code>hash</code>.  <a href="#ae97b736120f0a40aaa2528eac5eee9c2">More...</a><br /></td></tr>
<tr class="separator:ae97b736120f0a40aaa2528eac5eee9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381cfc02eb5b6db737f3f54760c62de1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a381cfc02eb5b6db737f3f54760c62de1">contains</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a381cfc02eb5b6db737f3f54760c62de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>hash</code>.  <a href="#a381cfc02eb5b6db737f3f54760c62de1">More...</a><br /></td></tr>
<tr class="separator:a381cfc02eb5b6db737f3f54760c62de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05cd0c142713445b72b0156b2259e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af05cd0c142713445b72b0156b2259e7d">get</a> (<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:af05cd0c142713445b72b0156b2259e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an item by it's <code>hash</code> and returns the item found.  <a href="#af05cd0c142713445b72b0156b2259e7d">More...</a><br /></td></tr>
<tr class="separator:af05cd0c142713445b72b0156b2259e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d13cdd83a629f0717f351d9469e6a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a89d13cdd83a629f0717f351d9469e6a9">clear</a> ()</td></tr>
<tr class="memdesc:a89d13cdd83a629f0717f351d9469e6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a89d13cdd83a629f0717f351d9469e6a9">More...</a><br /></td></tr>
<tr class="separator:a89d13cdd83a629f0717f351d9469e6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7107e17c23736e089d1cfb729308225b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a7107e17c23736e089d1cfb729308225b">empty</a> () const</td></tr>
<tr class="memdesc:a7107e17c23736e089d1cfb729308225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a7107e17c23736e089d1cfb729308225b">More...</a><br /></td></tr>
<tr class="separator:a7107e17c23736e089d1cfb729308225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade21e5094cc6f4f6d83cef308aeaf79f"><td class="memItemLeft" align="right" valign="top"><a id="ade21e5094cc6f4f6d83cef308aeaf79f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ade21e5094cc6f4f6d83cef308aeaf79f">size</a> () const</td></tr>
<tr class="memdesc:ade21e5094cc6f4f6d83cef308aeaf79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:ade21e5094cc6f4f6d83cef308aeaf79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c18ab94b0d6ccda71d54c41228d541"><td class="memItemLeft" align="right" valign="top"><a id="a37c18ab94b0d6ccda71d54c41228d541"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a82f15419e374ab40181e1aca8706f913">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a37c18ab94b0d6ccda71d54c41228d541">statistics</a> () const</td></tr>
<tr class="memdesc:a37c18ab94b0d6ccda71d54c41228d541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a37c18ab94b0d6ccda71d54c41228d541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32594ed127ac96e3336026e0be1c688"><td class="memItemLeft" align="right" valign="top"><a id="aa32594ed127ac96e3336026e0be1c688"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#aa32594ed127ac96e3336026e0be1c688">head_size</a> () const</td></tr>
<tr class="memdesc:aa32594ed127ac96e3336026e0be1c688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of head node. <br /></td></tr>
<tr class="separator:aa32594ed127ac96e3336026e0be1c688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e4053f9767a6b5aaf92ee2a5c1235c"><td class="memItemLeft" align="right" valign="top"><a id="ae1e4053f9767a6b5aaf92ee2a5c1235c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ae1e4053f9767a6b5aaf92ee2a5c1235c">array_node_size</a> () const</td></tr>
<tr class="memdesc:ae1e4053f9767a6b5aaf92ee2a5c1235c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the array node. <br /></td></tr>
<tr class="separator:ae1e4053f9767a6b5aaf92ee2a5c1235c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101f9c62ba5b4bf8a0af582144384643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a101f9c62ba5b4bf8a0af582144384643">get_level_statistics</a> (std::vector&lt; <a class="el" href="namespacecds_1_1container_1_1feldman__hashset.html#a53ccc7bd7719d07a866a4cbcc78e9f1e">feldman_hashset::level_statistics</a> &gt; &amp;<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a82f15419e374ab40181e1aca8706f913">stat</a>) const</td></tr>
<tr class="memdesc:a101f9c62ba5b4bf8a0af582144384643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects tree level statistics into <code>stat</code>.  <a href="#a101f9c62ba5b4bf8a0af582144384643">More...</a><br /></td></tr>
<tr class="separator:a101f9c62ba5b4bf8a0af582144384643"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a26cef6273458030840fb7187afc4b93b"><td class="memItemLeft" align="right" valign="top"><a id="a26cef6273458030840fb7187afc4b93b"></a>
static constexpr size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a26cef6273458030840fb7187afc4b93b">c_nHazardPtrCount</a> = base_class::c_nHazardPtrCount</td></tr>
<tr class="memdesc:a26cef6273458030840fb7187afc4b93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointers required. <br /></td></tr>
<tr class="separator:a26cef6273458030840fb7187afc4b93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fabcdf349b6c9d02bbe9bfd2d9b64ef"><td class="memItemLeft" align="right" valign="top"><a id="a2fabcdf349b6c9d02bbe9bfd2d9b64ef"></a>
static constexpr size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a2fabcdf349b6c9d02bbe9bfd2d9b64ef">c_hash_size</a> = base_class::c_hash_size</td></tr>
<tr class="memdesc:a2fabcdf349b6c9d02bbe9bfd2d9b64ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of <code>hash_type</code> in bytes, see <code><a class="el" href="structcds_1_1container_1_1feldman__hashset_1_1traits.html#a6a153ad8be3ac5f3ca3ba24fd4f072a2" title="The size of hash value in bytes. ">feldman_hashset::traits::hash_size</a></code> for explanation. <br /></td></tr>
<tr class="separator:a2fabcdf349b6c9d02bbe9bfd2d9b64ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread-safe iterators</h2></td></tr>
<tr class="memitem:af90583bd4b540dec1175ca03d5263cf5"><td class="memItemLeft" align="right" valign="top">typedef base_class::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af90583bd4b540dec1175ca03d5263cf5">iterator</a></td></tr>
<tr class="memdesc:af90583bd4b540dec1175ca03d5263cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional iterator.  <a href="#af90583bd4b540dec1175ca03d5263cf5">More...</a><br /></td></tr>
<tr class="separator:af90583bd4b540dec1175ca03d5263cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa01f0491fba55965ae8eeff6b40c71"><td class="memItemLeft" align="right" valign="top"><a id="a0fa01f0491fba55965ae8eeff6b40c71"></a>
typedef base_class::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0fa01f0491fba55965ae8eeff6b40c71">const_iterator</a></td></tr>
<tr class="memdesc:a0fa01f0491fba55965ae8eeff6b40c71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#cds_container_FeldmanHashSet_iterators">bidirectional const iterator</a> type <br /></td></tr>
<tr class="separator:a0fa01f0491fba55965ae8eeff6b40c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e5f70384370d83a7cc8429d0072207"><td class="memItemLeft" align="right" valign="top"><a id="ab5e5f70384370d83a7cc8429d0072207"></a>
typedef base_class::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ab5e5f70384370d83a7cc8429d0072207">reverse_iterator</a></td></tr>
<tr class="memdesc:ab5e5f70384370d83a7cc8429d0072207"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#cds_container_FeldmanHashSet_iterators">bidirectional reverse iterator</a> type <br /></td></tr>
<tr class="separator:ab5e5f70384370d83a7cc8429d0072207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25482c20b5a9cf905285d141942a3a8c"><td class="memItemLeft" align="right" valign="top"><a id="a25482c20b5a9cf905285d141942a3a8c"></a>
typedef base_class::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a25482c20b5a9cf905285d141942a3a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#cds_container_FeldmanHashSet_iterators">bidirectional reverse const iterator</a> type <br /></td></tr>
<tr class="separator:a25482c20b5a9cf905285d141942a3a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c8bbc4addc0dd823d52602bf405c57"><td class="memItemLeft" align="right" valign="top"><a id="a96c8bbc4addc0dd823d52602bf405c57"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af90583bd4b540dec1175ca03d5263cf5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a96c8bbc4addc0dd823d52602bf405c57">begin</a> ()</td></tr>
<tr class="memdesc:a96c8bbc4addc0dd823d52602bf405c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:a96c8bbc4addc0dd823d52602bf405c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e7cd98a9456e56aea93374fc702407"><td class="memItemLeft" align="right" valign="top"><a id="a82e7cd98a9456e56aea93374fc702407"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0fa01f0491fba55965ae8eeff6b40c71">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a82e7cd98a9456e56aea93374fc702407">begin</a> () const</td></tr>
<tr class="memdesc:a82e7cd98a9456e56aea93374fc702407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:a82e7cd98a9456e56aea93374fc702407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aeb203a7151b13a0edf8b2a7130048"><td class="memItemLeft" align="right" valign="top"><a id="a29aeb203a7151b13a0edf8b2a7130048"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0fa01f0491fba55965ae8eeff6b40c71">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a29aeb203a7151b13a0edf8b2a7130048">cbegin</a> ()</td></tr>
<tr class="memdesc:a29aeb203a7151b13a0edf8b2a7130048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:a29aeb203a7151b13a0edf8b2a7130048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc1f95fcca629c7105c99f788eb500a"><td class="memItemLeft" align="right" valign="top"><a id="a4cc1f95fcca629c7105c99f788eb500a"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af90583bd4b540dec1175ca03d5263cf5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a4cc1f95fcca629c7105c99f788eb500a">end</a> ()</td></tr>
<tr class="memdesc:a4cc1f95fcca629c7105c99f788eb500a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a4cc1f95fcca629c7105c99f788eb500a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c0ebc1825c4c3b0df85b9ad98b6387"><td class="memItemLeft" align="right" valign="top"><a id="ad5c0ebc1825c4c3b0df85b9ad98b6387"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0fa01f0491fba55965ae8eeff6b40c71">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ad5c0ebc1825c4c3b0df85b9ad98b6387">end</a> () const</td></tr>
<tr class="memdesc:ad5c0ebc1825c4c3b0df85b9ad98b6387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:ad5c0ebc1825c4c3b0df85b9ad98b6387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85746751e88e6ccf6d8b96b70ca7e7e"><td class="memItemLeft" align="right" valign="top"><a id="ac85746751e88e6ccf6d8b96b70ca7e7e"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0fa01f0491fba55965ae8eeff6b40c71">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac85746751e88e6ccf6d8b96b70ca7e7e">cend</a> ()</td></tr>
<tr class="memdesc:ac85746751e88e6ccf6d8b96b70ca7e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:ac85746751e88e6ccf6d8b96b70ca7e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301cd01645cdfaf439836b85a6dc6e71"><td class="memItemLeft" align="right" valign="top"><a id="a301cd01645cdfaf439836b85a6dc6e71"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ab5e5f70384370d83a7cc8429d0072207">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a301cd01645cdfaf439836b85a6dc6e71">rbegin</a> ()</td></tr>
<tr class="memdesc:a301cd01645cdfaf439836b85a6dc6e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:a301cd01645cdfaf439836b85a6dc6e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae895fefbdf76cdad2c4569c00adfe5cd"><td class="memItemLeft" align="right" valign="top"><a id="ae895fefbdf76cdad2c4569c00adfe5cd"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ae895fefbdf76cdad2c4569c00adfe5cd">rbegin</a> () const</td></tr>
<tr class="memdesc:ae895fefbdf76cdad2c4569c00adfe5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:ae895fefbdf76cdad2c4569c00adfe5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833f4caf3c03194fcca2cab5d8c6c6e9"><td class="memItemLeft" align="right" valign="top"><a id="a833f4caf3c03194fcca2cab5d8c6c6e9"></a>
<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a833f4caf3c03194fcca2cab5d8c6c6e9">crbegin</a> ()</td></tr>
<tr class="memdesc:a833f4caf3c03194fcca2cab5d8c6c6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:a833f4caf3c03194fcca2cab5d8c6c6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6dcc213716a64a69cd458bfb9dc0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ab5e5f70384370d83a7cc8429d0072207">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a5f6dcc213716a64a69cd458bfb9dc0a4">rend</a> ()</td></tr>
<tr class="memdesc:a5f6dcc213716a64a69cd458bfb9dc0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set.  <a href="#a5f6dcc213716a64a69cd458bfb9dc0a4">More...</a><br /></td></tr>
<tr class="separator:a5f6dcc213716a64a69cd458bfb9dc0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0819966cafc740dfea84af854926e02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a0819966cafc740dfea84af854926e02b">rend</a> () const</td></tr>
<tr class="memdesc:a0819966cafc740dfea84af854926e02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed set.  <a href="#a0819966cafc740dfea84af854926e02b">More...</a><br /></td></tr>
<tr class="separator:a0819966cafc740dfea84af854926e02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771323f8e07f125b6a2b673568f5352a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a771323f8e07f125b6a2b673568f5352a">crend</a> ()</td></tr>
<tr class="memdesc:a771323f8e07f125b6a2b673568f5352a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed set.  <a href="#a771323f8e07f125b6a2b673568f5352a">More...</a><br /></td></tr>
<tr class="separator:a771323f8e07f125b6a2b673568f5352a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_feldman_hash_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a05f120d89776502aaa8c80362a33983c inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a05f120d89776502aaa8c80362a33983c"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a05f120d89776502aaa8c80362a33983c">gc</a></td></tr>
<tr class="memdesc:a05f120d89776502aaa8c80362a33983c inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a05f120d89776502aaa8c80362a33983c inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5ac45b259f0a4e557a114dd163b970 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="afe5ac45b259f0a4e557a114dd163b970"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afe5ac45b259f0a4e557a114dd163b970">value_type</a></td></tr>
<tr class="memdesc:afe5ac45b259f0a4e557a114dd163b970 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the set <br /></td></tr>
<tr class="separator:afe5ac45b259f0a4e557a114dd163b970 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0296247775c793f080447000da85b2df inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a0296247775c793f080447000da85b2df"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a0296247775c793f080447000da85b2df">traits</a></td></tr>
<tr class="memdesc:a0296247775c793f080447000da85b2df inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter, see <code><a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1traits.html" title="FeldmanHashSet traits ">feldman_hashset::traits</a></code>. <br /></td></tr>
<tr class="separator:a0296247775c793f080447000da85b2df inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106d6fe29b03bb6ebc34d1dee94749ed inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a106d6fe29b03bb6ebc34d1dee94749ed"></a>
typedef traits::hash_accessor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a106d6fe29b03bb6ebc34d1dee94749ed">hash_accessor</a></td></tr>
<tr class="memdesc:a106d6fe29b03bb6ebc34d1dee94749ed inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash accessor functor. <br /></td></tr>
<tr class="separator:a106d6fe29b03bb6ebc34d1dee94749ed inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a3d19d9e30a4bd947f8cdfb913ced6 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ab4a3d19d9e30a4bd947f8cdfb913ced6"></a>
typedef base_class::hash_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a></td></tr>
<tr class="memdesc:ab4a3d19d9e30a4bd947f8cdfb913ced6 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash type deduced from <code>hash_accessor</code> return type. <br /></td></tr>
<tr class="separator:ab4a3d19d9e30a4bd947f8cdfb913ced6 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af360c8f18c7d495ca8678ddd145eecd8 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="af360c8f18c7d495ca8678ddd145eecd8"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#af360c8f18c7d495ca8678ddd145eecd8">disposer</a></td></tr>
<tr class="memdesc:af360c8f18c7d495ca8678ddd145eecd8 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">data node disposer <br /></td></tr>
<tr class="separator:af360c8f18c7d495ca8678ddd145eecd8 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dced38c08258a1d4488b8928591c606 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a9dced38c08258a1d4488b8928591c606"></a>
typedef base_class::hash_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a9dced38c08258a1d4488b8928591c606">hash_comparator</a></td></tr>
<tr class="memdesc:a9dced38c08258a1d4488b8928591c606 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash compare functor based on <code>traits::compare</code> and <code>traits::less</code> options <br /></td></tr>
<tr class="separator:a9dced38c08258a1d4488b8928591c606 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f51c85b86987e289394256c1ab12fa inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a82f51c85b86987e289394256c1ab12fa"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a82f51c85b86987e289394256c1ab12fa">item_counter</a></td></tr>
<tr class="memdesc:a82f51c85b86987e289394256c1ab12fa inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a82f51c85b86987e289394256c1ab12fa inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa65224d6a7d12cc7c4c2d4bac0920e6 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="aaa65224d6a7d12cc7c4c2d4bac0920e6"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aaa65224d6a7d12cc7c4c2d4bac0920e6">node_allocator</a></td></tr>
<tr class="memdesc:aaa65224d6a7d12cc7c4c2d4bac0920e6 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array node allocator. <br /></td></tr>
<tr class="separator:aaa65224d6a7d12cc7c4c2d4bac0920e6 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87391ff3aa9632b6ce0bd776063e1f69 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a87391ff3aa9632b6ce0bd776063e1f69"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a87391ff3aa9632b6ce0bd776063e1f69">memory_model</a></td></tr>
<tr class="memdesc:a87391ff3aa9632b6ce0bd776063e1f69 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory model. <br /></td></tr>
<tr class="separator:a87391ff3aa9632b6ce0bd776063e1f69 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92fa36a5c28493d99ffaf3b474001a8 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ae92fa36a5c28493d99ffaf3b474001a8"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ae92fa36a5c28493d99ffaf3b474001a8">back_off</a></td></tr>
<tr class="memdesc:ae92fa36a5c28493d99ffaf3b474001a8 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backoff strategy. <br /></td></tr>
<tr class="separator:ae92fa36a5c28493d99ffaf3b474001a8 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786ccd2787862d76d07ca83e5799087 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a1786ccd2787862d76d07ca83e5799087"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a1786ccd2787862d76d07ca83e5799087">stat</a></td></tr>
<tr class="memdesc:a1786ccd2787862d76d07ca83e5799087 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics type. <br /></td></tr>
<tr class="separator:a1786ccd2787862d76d07ca83e5799087 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709d57dbb4be4af2acf045443e486f63 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a709d57dbb4be4af2acf045443e486f63"></a>
typedef gc::template <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a709d57dbb4be4af2acf045443e486f63">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afe5ac45b259f0a4e557a114dd163b970">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a709d57dbb4be4af2acf045443e486f63">guarded_ptr</a></td></tr>
<tr class="memdesc:a709d57dbb4be4af2acf045443e486f63 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a709d57dbb4be4af2acf045443e486f63 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d9c95b73441bab61f345449c1fac7 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a083d9c95b73441bab61f345449c1fac7"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1level__statistics.html">feldman_hashset::level_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a083d9c95b73441bab61f345449c1fac7">level_statistics</a></td></tr>
<tr class="memdesc:a083d9c95b73441bab61f345449c1fac7 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level statistics. <br /></td></tr>
<tr class="separator:a083d9c95b73441bab61f345449c1fac7 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89726d457e5feedd7da1f6e1c82675a inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="aa89726d457e5feedd7da1f6e1c82675a"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aa89726d457e5feedd7da1f6e1c82675a">iterator</a></td></tr>
<tr class="memdesc:aa89726d457e5feedd7da1f6e1c82675a inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#cds_intrusive_FeldmanHashSet_iterators">bidirectional iterator</a> type <br /></td></tr>
<tr class="separator:aa89726d457e5feedd7da1f6e1c82675a inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac668a9cbaf6ce9a4939ac865c1d327af inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ac668a9cbaf6ce9a4939ac865c1d327af"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ac668a9cbaf6ce9a4939ac865c1d327af">const_iterator</a></td></tr>
<tr class="memdesc:ac668a9cbaf6ce9a4939ac865c1d327af inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#cds_intrusive_FeldmanHashSet_iterators">bidirectional const iterator</a> type <br /></td></tr>
<tr class="separator:ac668a9cbaf6ce9a4939ac865c1d327af inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33bddf4f01c2be49c55f827c80076c5 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ae33bddf4f01c2be49c55f827c80076c5"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ae33bddf4f01c2be49c55f827c80076c5">reverse_iterator</a></td></tr>
<tr class="memdesc:ae33bddf4f01c2be49c55f827c80076c5 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#cds_intrusive_FeldmanHashSet_iterators">bidirectional reverse iterator</a> type <br /></td></tr>
<tr class="separator:ae33bddf4f01c2be49c55f827c80076c5 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6412635df30cc5d1ee69caeec8941ab2 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a6412635df30cc5d1ee69caeec8941ab2"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6412635df30cc5d1ee69caeec8941ab2">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a6412635df30cc5d1ee69caeec8941ab2 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#cds_intrusive_FeldmanHashSet_iterators">bidirectional reverse const iterator</a> type <br /></td></tr>
<tr class="separator:a6412635df30cc5d1ee69caeec8941ab2 inherit pro_types_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a2d151c6fef171124b3e8ba8ad134c506 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a2d151c6fef171124b3e8ba8ad134c506">FeldmanHashSet</a> (size_t head_bits=8, size_t array_bits=4)</td></tr>
<tr class="memdesc:a2d151c6fef171124b3e8ba8ad134c506 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a2d151c6fef171124b3e8ba8ad134c506">More...</a><br /></td></tr>
<tr class="separator:a2d151c6fef171124b3e8ba8ad134c506 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4d77f22c3b0064348f8a855944221a inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a6c4d77f22c3b0064348f8a855944221a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6c4d77f22c3b0064348f8a855944221a">~FeldmanHashSet</a> ()</td></tr>
<tr class="memdesc:a6c4d77f22c3b0064348f8a855944221a inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the set and frees all data. <br /></td></tr>
<tr class="separator:a6c4d77f22c3b0064348f8a855944221a inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152c00eb5372e75f75c473560d90b355 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a152c00eb5372e75f75c473560d90b355">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afe5ac45b259f0a4e557a114dd163b970">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a152c00eb5372e75f75c473560d90b355 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a152c00eb5372e75f75c473560d90b355">More...</a><br /></td></tr>
<tr class="separator:a152c00eb5372e75f75c473560d90b355 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715e70071dac885e961a64199d6215bb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a715e70071dac885e961a64199d6215bb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a715e70071dac885e961a64199d6215bb">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afe5ac45b259f0a4e557a114dd163b970">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a715e70071dac885e961a64199d6215bb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a715e70071dac885e961a64199d6215bb">More...</a><br /></td></tr>
<tr class="separator:a715e70071dac885e961a64199d6215bb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad645daa5c6e49a9d1b6a76e42fa54411 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ad645daa5c6e49a9d1b6a76e42fa54411">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afe5ac45b259f0a4e557a114dd163b970">value_type</a> &amp;val, bool bInsert=true)</td></tr>
<tr class="memdesc:ad645daa5c6e49a9d1b6a76e42fa54411 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ad645daa5c6e49a9d1b6a76e42fa54411">More...</a><br /></td></tr>
<tr class="separator:ad645daa5c6e49a9d1b6a76e42fa54411 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a0939e0565683412e02a53efc8a4b7 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a40a0939e0565683412e02a53efc8a4b7">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afe5ac45b259f0a4e557a114dd163b970">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:a40a0939e0565683412e02a53efc8a4b7 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a40a0939e0565683412e02a53efc8a4b7">More...</a><br /></td></tr>
<tr class="separator:a40a0939e0565683412e02a53efc8a4b7 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaa2ed87a48804b0844e931548bfdc3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#abfaa2ed87a48804b0844e931548bfdc3">erase</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:abfaa2ed87a48804b0844e931548bfdc3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#abfaa2ed87a48804b0844e931548bfdc3">More...</a><br /></td></tr>
<tr class="separator:abfaa2ed87a48804b0844e931548bfdc3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad311c9369a28ac2173fc42663ef8b5fe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ad311c9369a28ac2173fc42663ef8b5fe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ad311c9369a28ac2173fc42663ef8b5fe">erase</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a> const &amp;hash, Func f)</td></tr>
<tr class="memdesc:ad311c9369a28ac2173fc42663ef8b5fe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ad311c9369a28ac2173fc42663ef8b5fe">More...</a><br /></td></tr>
<tr class="separator:ad311c9369a28ac2173fc42663ef8b5fe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee2dbd1e64fc42de979ca75837fec02 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a0ee2dbd1e64fc42de979ca75837fec02">erase_at</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aa89726d457e5feedd7da1f6e1c82675a">iterator</a> const &amp;iter)</td></tr>
<tr class="memdesc:a0ee2dbd1e64fc42de979ca75837fec02 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item pointed by iterator <code>iter</code>.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a0ee2dbd1e64fc42de979ca75837fec02">More...</a><br /></td></tr>
<tr class="separator:a0ee2dbd1e64fc42de979ca75837fec02 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0971c42e65ff0f876e9581c4faf0f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a709d57dbb4be4af2acf045443e486f63">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6a0971c42e65ff0f876e9581c4faf0f5">extract</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a6a0971c42e65ff0f876e9581c4faf0f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>hash</code>.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6a0971c42e65ff0f876e9581c4faf0f5">More...</a><br /></td></tr>
<tr class="separator:a6a0971c42e65ff0f876e9581c4faf0f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb6aac67a2e32bb6f914518eb587f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a3beb6aac67a2e32bb6f914518eb587f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a3beb6aac67a2e32bb6f914518eb587f5">find</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a> const &amp;hash, Func f)</td></tr>
<tr class="memdesc:a3beb6aac67a2e32bb6f914518eb587f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an item by it's <code>hash</code>.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a3beb6aac67a2e32bb6f914518eb587f5">More...</a><br /></td></tr>
<tr class="separator:a3beb6aac67a2e32bb6f914518eb587f5 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488c54d86a68e9c156975a3117d07f8 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#af488c54d86a68e9c156975a3117d07f8">contains</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:af488c54d86a68e9c156975a3117d07f8 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>hash</code>.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#af488c54d86a68e9c156975a3117d07f8">More...</a><br /></td></tr>
<tr class="separator:af488c54d86a68e9c156975a3117d07f8 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9909832c40c32e6ce0cb83594543f inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a709d57dbb4be4af2acf045443e486f63">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a9fd9909832c40c32e6ce0cb83594543f">get</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ab4a3d19d9e30a4bd947f8cdfb913ced6">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a9fd9909832c40c32e6ce0cb83594543f inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an item by it's <code>hash</code> and returns the item found.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a9fd9909832c40c32e6ce0cb83594543f">More...</a><br /></td></tr>
<tr class="separator:a9fd9909832c40c32e6ce0cb83594543f inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001547e885f8dedce855bd416b028bc9 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a001547e885f8dedce855bd416b028bc9">clear</a> ()</td></tr>
<tr class="memdesc:a001547e885f8dedce855bd416b028bc9 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a001547e885f8dedce855bd416b028bc9">More...</a><br /></td></tr>
<tr class="separator:a001547e885f8dedce855bd416b028bc9 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d947050e1ae6690f5274ca3ad4adc inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a504d947050e1ae6690f5274ca3ad4adc">empty</a> () const</td></tr>
<tr class="memdesc:a504d947050e1ae6690f5274ca3ad4adc inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a504d947050e1ae6690f5274ca3ad4adc">More...</a><br /></td></tr>
<tr class="separator:a504d947050e1ae6690f5274ca3ad4adc inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3f097a257a6f03d436b599c31902a3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a6b3f097a257a6f03d436b599c31902a3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6b3f097a257a6f03d436b599c31902a3">size</a> () const</td></tr>
<tr class="memdesc:a6b3f097a257a6f03d436b599c31902a3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a6b3f097a257a6f03d436b599c31902a3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b584a90f92964293bc3f0e754ebb13 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a26b584a90f92964293bc3f0e754ebb13"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a1786ccd2787862d76d07ca83e5799087">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a26b584a90f92964293bc3f0e754ebb13">statistics</a> () const</td></tr>
<tr class="memdesc:a26b584a90f92964293bc3f0e754ebb13 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a26b584a90f92964293bc3f0e754ebb13 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f3dfa1f0f13a71ba35f22380ca97c3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a78f3dfa1f0f13a71ba35f22380ca97c3">get_level_statistics</a> (std::vector&lt; <a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1level__statistics.html">feldman_hashset::level_statistics</a> &gt; &amp;<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a1786ccd2787862d76d07ca83e5799087">stat</a>) const</td></tr>
<tr class="memdesc:a78f3dfa1f0f13a71ba35f22380ca97c3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects tree level statistics into <code>stat</code>.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a78f3dfa1f0f13a71ba35f22380ca97c3">More...</a><br /></td></tr>
<tr class="separator:a78f3dfa1f0f13a71ba35f22380ca97c3 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a598e1feb100e263adf4a360d9070a inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aa89726d457e5feedd7da1f6e1c82675a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a72a598e1feb100e263adf4a360d9070a">begin</a> ()</td></tr>
<tr class="memdesc:a72a598e1feb100e263adf4a360d9070a inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a72a598e1feb100e263adf4a360d9070a">More...</a><br /></td></tr>
<tr class="separator:a72a598e1feb100e263adf4a360d9070a inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6ef6fb2c3b13e67c5994abc53c91e0 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="afc6ef6fb2c3b13e67c5994abc53c91e0"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ac668a9cbaf6ce9a4939ac865c1d327af">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#afc6ef6fb2c3b13e67c5994abc53c91e0">begin</a> () const</td></tr>
<tr class="memdesc:afc6ef6fb2c3b13e67c5994abc53c91e0 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:afc6ef6fb2c3b13e67c5994abc53c91e0 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fbd18a45ebed133c411f9c96a34fe7 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a58fbd18a45ebed133c411f9c96a34fe7"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ac668a9cbaf6ce9a4939ac865c1d327af">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a58fbd18a45ebed133c411f9c96a34fe7">cbegin</a> ()</td></tr>
<tr class="memdesc:a58fbd18a45ebed133c411f9c96a34fe7 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:a58fbd18a45ebed133c411f9c96a34fe7 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70b6519c75a7a8d896eb48c948d84e0 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ae70b6519c75a7a8d896eb48c948d84e0"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aa89726d457e5feedd7da1f6e1c82675a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ae70b6519c75a7a8d896eb48c948d84e0">end</a> ()</td></tr>
<tr class="memdesc:ae70b6519c75a7a8d896eb48c948d84e0 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:ae70b6519c75a7a8d896eb48c948d84e0 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722eab90da087ad50a0df2a473a3de5b inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a722eab90da087ad50a0df2a473a3de5b"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ac668a9cbaf6ce9a4939ac865c1d327af">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a722eab90da087ad50a0df2a473a3de5b">end</a> () const</td></tr>
<tr class="memdesc:a722eab90da087ad50a0df2a473a3de5b inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a722eab90da087ad50a0df2a473a3de5b inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea81f4478d3c8b913cc56e1f7836467 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a7ea81f4478d3c8b913cc56e1f7836467"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ac668a9cbaf6ce9a4939ac865c1d327af">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a7ea81f4478d3c8b913cc56e1f7836467">cend</a> ()</td></tr>
<tr class="memdesc:a7ea81f4478d3c8b913cc56e1f7836467 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a7ea81f4478d3c8b913cc56e1f7836467 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553b1c0eab95702a3bc1eace346aacfe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a553b1c0eab95702a3bc1eace346aacfe"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ae33bddf4f01c2be49c55f827c80076c5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a553b1c0eab95702a3bc1eace346aacfe">rbegin</a> ()</td></tr>
<tr class="memdesc:a553b1c0eab95702a3bc1eace346aacfe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:a553b1c0eab95702a3bc1eace346aacfe inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e8e9ca45cdb5288d93dd69e88c9ffb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ac9e8e9ca45cdb5288d93dd69e88c9ffb"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6412635df30cc5d1ee69caeec8941ab2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ac9e8e9ca45cdb5288d93dd69e88c9ffb">rbegin</a> () const</td></tr>
<tr class="memdesc:ac9e8e9ca45cdb5288d93dd69e88c9ffb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:ac9e8e9ca45cdb5288d93dd69e88c9ffb inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab62394b6d24671cbde13257a2dcc21 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="a3ab62394b6d24671cbde13257a2dcc21"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6412635df30cc5d1ee69caeec8941ab2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a3ab62394b6d24671cbde13257a2dcc21">crbegin</a> ()</td></tr>
<tr class="memdesc:a3ab62394b6d24671cbde13257a2dcc21 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:a3ab62394b6d24671cbde13257a2dcc21 inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53818eeb04cad9ae79c62ea0648187ec inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ae33bddf4f01c2be49c55f827c80076c5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a53818eeb04cad9ae79c62ea0648187ec">rend</a> ()</td></tr>
<tr class="memdesc:a53818eeb04cad9ae79c62ea0648187ec inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a53818eeb04cad9ae79c62ea0648187ec">More...</a><br /></td></tr>
<tr class="separator:a53818eeb04cad9ae79c62ea0648187ec inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb917c72f6ccb5887c34e2de673338f inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6412635df30cc5d1ee69caeec8941ab2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aafb917c72f6ccb5887c34e2de673338f">rend</a> () const</td></tr>
<tr class="memdesc:aafb917c72f6ccb5887c34e2de673338f inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aafb917c72f6ccb5887c34e2de673338f">More...</a><br /></td></tr>
<tr class="separator:aafb917c72f6ccb5887c34e2de673338f inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244b7eae551fa75e887fc59562df7a8b inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a6412635df30cc5d1ee69caeec8941ab2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a244b7eae551fa75e887fc59562df7a8b">crend</a> ()</td></tr>
<tr class="memdesc:a244b7eae551fa75e887fc59562df7a8b inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed set.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a244b7eae551fa75e887fc59562df7a8b">More...</a><br /></td></tr>
<tr class="separator:a244b7eae551fa75e887fc59562df7a8b inherit pro_methods_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:aa39a5cc96d85ced0944fd149b4397f19 inherit pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="aa39a5cc96d85ced0944fd149b4397f19"></a>
static constexpr size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#aa39a5cc96d85ced0944fd149b4397f19">c_nHazardPtrCount</a> = 2</td></tr>
<tr class="memdesc:aa39a5cc96d85ced0944fd149b4397f19 inherit pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointers required. <br /></td></tr>
<tr class="separator:aa39a5cc96d85ced0944fd149b4397f19 inherit pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58a884462dcc940eabca2212500a8d3 inherit pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memItemLeft" align="right" valign="top"><a id="ae58a884462dcc940eabca2212500a8d3"></a>
static constexpr size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#ae58a884462dcc940eabca2212500a8d3">c_hash_size</a> = base_class::c_hash_size</td></tr>
<tr class="memdesc:ae58a884462dcc940eabca2212500a8d3 inherit pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of hash_type in bytes, see <code><a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1traits.html#a619303399dda08c2444dbd0d008ce049" title="The size of hash value in bytes. ">feldman_hashset::traits::hash_size</a></code> for explanation. <br /></td></tr>
<tr class="separator:ae58a884462dcc940eabca2212500a8d3 inherit pro_static_attribs_classcds_1_1intrusive_1_1_feldman_hash_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, typename T, class Traits = feldman_hashset::traits&gt;<br />
class cds::container::FeldmanHashSet&lt; GC, T, Traits &gt;</h3>

<p>Hash set based on multi-level array. </p>
<p><a class="anchor" id="cds_container_FeldmanHashSet_hp"></a> Source:</p><ul>
<li>[2013] Steven Feldman, Pierre LaBorde, Damian Dechev "Concurrent Multi-level Arrays:
         Wait-free Extensible Hash Maps"</li>
</ul>
<p>[From the paper] The hardest problem encountered while developing a parallel hash map is how to perform a global resize, the process of redistributing the elements in a hash map that occurs when adding new buckets. The negative impact of blocking synchronization is multiplied during a global resize, because all threads will be forced to wait on the thread that is performing the involved process of resizing the hash map and redistributing the elements. <code>FeldmanHashSet</code> implementation avoids global resizes through new array allocation. By allowing concurrent expansion this structure is free from the overhead of an explicit resize, which facilitates concurrent operations.</p>
<p>The presented design includes dynamic hashing, the use of sub-arrays within the hash map data structure; which, in combination with <b>perfect hashing</b>, means that each element has a unique final, as well as current, position. It is important to note that the perfect hash function required by our hash map is trivial to realize as any hash function that permutes the bits of the key is suitable. This is possible because of our approach to the hash function; we require that it produces hash values that are equal in size to that of the key. We know that if we expand the hash map a fixed number of times there can be no collision as duplicate keys are not provided for in the standard semantics of a hash map.</p>
<p><code>FeldmanHashSet</code> is a multi-level array which has an internal structure similar to a tree: </p><div class="image">
<img src="feldman_hashset.png" alt="feldman_hashset.png"/>
</div>
<p> The multi-level array differs from a tree in that each position on the tree could hold an array of nodes or a single node. A position that holds a single node is a <code>dataNode</code> which holds the hash value of a key and the value that is associated with that key; it is a simple struct holding two variables. A <code>dataNode</code> in the multi-level array could be marked. A <code>markedDataNode</code> refers to a pointer to a <code>dataNode</code> that has been bitmarked at the least significant bit (LSB) of the pointer to the node. This signifies that this <code>dataNode</code> is contended. An expansion must occur at this node; any thread that sees this <code>markedDataNode</code> will try to replace it with an <code>arrayNode</code>; which is a position that holds an array of nodes. The pointer to an <code>arrayNode</code> is differentiated from that of a pointer to a <code>dataNode</code> by a bitmark on the second-least significant bit.</p>
<p><code>FeldmanHashSet</code> multi-level array is similar to a tree in that we keep a pointer to the root, which is a memory array called <code>head</code>. The length of the <code>head</code> memory array is unique, whereas every other <code>arrayNode</code> has a uniform length; a normal <code>arrayNode</code> has a fixed power-of-two length equal to the binary logarithm of a variable called <code>arrayLength</code>. The maximum depth of the tree, <code>maxDepth</code>, is the maximum number of pointers that must be followed to reach any node. We define <code>currentDepth</code> as the number of memory arrays that we need to traverse to reach the <code>arrayNode</code> on which we need to operate; this is initially one, because of <code>head</code>.</p>
<p>That approach to the structure of the hash set uses an extensible hashing scheme; <b> the hash value is treated as a bit string</b> and rehash incrementally.</p>
<dl class="section note"><dt>Note</dt><dd>Two important things you should keep in mind when you're using <code>FeldmanHashSet</code>:<ul>
<li>all keys must be fixed-size. It means that you cannot use <code>std::string</code> as a key for <code>FeldmanHashSet</code>. Instead, for the strings you should use well-known hashing algorithms like <a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA1, SHA2</a>, <a href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash</a>, <a href="https://en.wikipedia.org/wiki/CityHash">CityHash</a> or its successor <a href="https://code.google.com/p/farmhash/">FarmHash</a> and so on, which converts variable-length strings to fixed-length bit-strings, and use that hash as a key in <code>FeldmanHashSet</code>.</li>
<li><code>FeldmanHashSet</code> uses a perfect hashing. It means that if two different keys, for example, of type <code>std::string</code>, have identical hash then you cannot insert both that keys in the set. <code>FeldmanHashSet</code> does not maintain the key, it maintains its fixed-size hash value.</li>
</ul>
</dd></dl>
<p>The set supports <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#cds_container_FeldmanHashSet_iterators">bidirectional thread-safe iterators</a>.</p>
<p>Template parameters:</p><ul>
<li><code>GC</code> - safe memory reclamation schema. Can be <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer SMR (Safe Memory Reclamation) ">gc::HP</a></code>, <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic (adaptie) Hazard Pointer SMR. ">gc::DHP</a></code> or one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_type">RCU type</a></li>
<li><code>T</code> - a value type to be stored in the set</li>
<li><code>Traits</code> - type traits, the structure based on <code><a class="el" href="structcds_1_1container_1_1feldman__hashset_1_1traits.html" title="FeldmanHashSet traits ">feldman_hashset::traits</a></code> or result of <code><a class="el" href="structcds_1_1container_1_1feldman__hashset_1_1make__traits.html" title="Metafunction converting option list to feldman_hashset::traits. ">feldman_hashset::make_traits</a></code> metafunction. <code>Traits</code> is the mandatory argument because it has one mandatory type - an <a class="el" href="structcds_1_1container_1_1feldman__hashset_1_1traits.html#ae0d4c51659ec6c65556399227ca8e5bb">accessor</a> to hash value of <code>T</code>. The set algorithm does not calculate that hash value.</li>
</ul>
<p>There are several specializations of <code>FeldmanHashSet</code> for each <code>GC</code>. You should include:</p><ul>
<li><code>&lt;cds/container/feldman_hashset_hp.h&gt;</code> for <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer SMR (Safe Memory Reclamation) ">gc::HP</a></code> garbage collector</li>
<li><code>&lt;cds/container/feldman_hashset_dhp.h&gt;</code> for <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic (adaptie) Hazard Pointer SMR. ">gc::DHP</a></code> garbage collector</li>
<li><code>&lt;cds/container/feldman_hashset_rcu.h&gt;</code> for <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_FeldmanHashSet_rcu">RCU type</a>. RCU specialization has a slightly different interface. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af90583bd4b540dec1175ca03d5263cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90583bd4b540dec1175ca03d5263cf5">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::iterator <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af90583bd4b540dec1175ca03d5263cf5">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bidirectional iterator. </p>
<p><a class="anchor" id="cds_container_FeldmanHashSet_iterators"></a>The set supports thread-safe iterators: you may iterate over the set in multi-threaded environment. It is guaranteed that the iterators will remain valid even if another thread deletes the node the iterator points to: Hazard Pointer embedded into the iterator object protects the node from physical reclamation.</p>
<dl class="section note"><dt>Note</dt><dd>Since the iterator object contains hazard pointer that is a thread-local resource, the iterator should not be passed to another thread.</dd></dl>
<p>Each iterator object supports the following interface:</p><ul>
<li>dereference operators: <div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a> [<span class="keyword">const</span>] * operator -&gt;() noexcept</div><div class="line"><a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a> [const] &amp; operator *() noexcept</div></div><!-- fragment --></li>
<li>pre-increment and pre-decrement. Post-operators is not supported</li>
<li>equality operators <code>==</code> and <code>!=</code>. Iterators are equal iff they point to the same cell of the same array node. Note that for two iterators <code>it1</code> and <code>it2</code>, the conditon <code> it1 == it2 </code> does not entail <code> &amp;(*it1) == &amp;(*it2) </code></li>
<li>helper member function <code>release()</code> that clears internal hazard pointer. After <code>release()</code> the iterator points to <code>nullptr</code> but it still remain valid: further iterating is possible.</li>
</ul>
<p>During iteration you may safely erase any item from the set; <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#afaaafb57182d7e59ae52471a5acab612">erase_at()</a> function call doesn't invalidate any iterator. If some iterator points to the item to be erased, that item is not deleted immediately but only after that iterator will be advanced forward or backward.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible the item can be iterated more that once, for example, if an iterator points to the item in array node that is being splitted. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aedea0487f262e14f634afb8c362f54fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedea0487f262e14f634afb8c362f54fb">&#9670;&nbsp;</a></span>FeldmanHashSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">FeldmanHashSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head_bits</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>array_bits</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates empty set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head_bits</td><td>- 2<sup>head_bits</sup> specifies the size of head array, minimum is 4. </td></tr>
    <tr><td class="paramname">array_bits</td><td>- 2<sup>array_bits</sup> specifies the size of array node, minimum is 2.</td></tr>
  </table>
  </dd>
</dl>
<p>Equation for <code>head_bits</code> and <code>array_bits:</code> </p><div class="fragment"><div class="line"><span class="keyword">sizeof</span>(<a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a>) * 8 == head_bits + N * array_bits</div></div><!-- fragment --><p> where <code>N</code> is multi-level array depth. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a89d13cdd83a629f0717f351d9469e6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d13cdd83a629f0717f351d9469e6a9">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic) </p>
<p>The function unlink all data node from the set. The function is not atomic but is thread-safe. After <code>clear</code>() the set may not be empty because another threads may insert items. </p>

</div>
</div>
<a id="a381cfc02eb5b6db737f3f54760c62de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381cfc02eb5b6db737f3f54760c62de1">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>hash</code>. </p>
<p>The function searches the item by its <code>hash</code> and returns <code>true</code> if it is found, or <code>false</code> otherwise. </p>

</div>
</div>
<a id="a771323f8e07f125b6a2b673568f5352a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771323f8e07f125b6a2b673568f5352a">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a> <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element following the last element of the reversed set. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a9164538d39bbca5999658158ca344b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9164538d39bbca5999658158ca344b65">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code>value_type</code> created in-place from <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a7107e17c23736e089d1cfb729308225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7107e17c23736e089d1cfb729308225b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. Thus, the correct item counting feature is an important part of the set implementation. </p>

</div>
</div>
<a id="a7e1c4e9f3d8cea14c0823c8a1f83589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1c4e9f3d8cea14c0823c8a1f83589d">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p>The function searches <code>hash</code> in the set, deletes the item found, and returns <code>true</code>. If that item is not found the function returns <code>false</code>. </p>

</div>
</div>
<a id="a635a611a3710eefc545c293eab65f1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635a611a3710eefc545c293eab65f1bf">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p>The function searches <code>hash</code> in the set, call <code>f</code> functor with item found, and deltes the element from the set.</p>
<p>The <code>Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>If <code>hash</code> is not found the function returns <code>false</code>. </p>

</div>
</div>
<a id="afaaafb57182d7e59ae52471a5acab612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaaafb57182d7e59ae52471a5acab612">&#9670;&nbsp;</a></span>erase_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::erase_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#af90583bd4b540dec1175ca03d5263cf5">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item pointed by iterator <code>iter</code>. </p>
<p>Returns <code>true</code> if the operation is successful, <code>false</code> otherwise.</p>
<p>The function does not invalidate the iterator, it remains valid and can be used for further traversing. </p>

</div>
</div>
<a id="a1c63a14b6e2bc8b5b48224f3472f469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c63a14b6e2bc8b5b48224f3472f469c">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item with specified <code>hash</code>. </p>
<p>The function searches <code>hash</code> in the set, unlinks it from the set, and returns a guarded pointer to the item extracted. If <code>hash</code> is not found the function returns an empty guarded pointer.</p>
<p>The item returned is reclaimed by garbage collector <code>GC</code> when returned <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a> object to be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet&lt; your_template_args &gt;</a> my_set;</div><div class="line">my_set theSet;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    my_set::guarded_ptr gp( theSet.extract( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ae97b736120f0a40aaa2528eac5eee9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97b736120f0a40aaa2528eac5eee9c2">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an item by it's <code>hash</code>. </p>
<p>The function searches the item by <code>hash</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during the functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to prevent unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>hash</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="af05cd0c142713445b72b0156b2259e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05cd0c142713445b72b0156b2259e7d">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac28813a91b3e98f2e4799a93ee1d7a3c">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a549898310828bd413825288f14427468">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an item by it's <code>hash</code> and returns the item found. </p>
<p>The function searches the item by its <code>hash</code> and returns the guarded pointer to the item found. If <code>hash</code> is not found the function returns an empty <code>guarded_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet&lt; your_template_params &gt;</a>  my_set;</div><div class="line">my_set theSet;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    my_set::guarded_ptr gp( theSet.get( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( theSet.get( 5 )) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a101f9c62ba5b4bf8a0af582144384643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101f9c62ba5b4bf8a0af582144384643">&#9670;&nbsp;</a></span>get_level_statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::get_level_statistics </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecds_1_1container_1_1feldman__hashset.html#a53ccc7bd7719d07a866a4cbcc78e9f1e">feldman_hashset::level_statistics</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects tree level statistics into <code>stat</code>. </p>
<p>The function traverses the set and collects statistics for each level of the tree into <code><a class="el" href="namespacecds_1_1container_1_1feldman__hashset.html#a53ccc7bd7719d07a866a4cbcc78e9f1e" title="FeldmanHashSet level statistics ">feldman_hashset::level_statistics</a></code> struct. The element of <code>stat</code>[i] represents statistics for level <code>i</code>, level 0 is head array. The function is thread-safe and may be called in multi-threaded environment.</p>
<p>Result can be useful for estimating efficiency of hash functor you use. </p>

</div>
</div>
<a id="a278d92869523f6e94066ee585e4ec47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278d92869523f6e94066ee585e4ec47a">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element. </p>
<p>The function creates an element with copy of <code>val</code> value and then inserts it into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete hash for the element. The object of <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a0a22e47e36a7c6a1f0bd60fa41aaff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a22e47e36a7c6a1f0bd60fa41aaff1b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-fields of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a>&amp; val );</div></div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success. </p>

</div>
</div>
<a id="a5f6dcc213716a64a69cd458bfb9dc0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6dcc213716a64a69cd458bfb9dc0a4">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#ab5e5f70384370d83a7cc8429d0072207">reverse_iterator</a> <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a0819966cafc740dfea84af854926e02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0819966cafc740dfea84af854926e02b">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html#a25482c20b5a9cf905285d141942a3a8c">const_reverse_iterator</a> <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element following the last element of the reversed set. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="add7d8531e651ab83ce53451cc5034664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7d8531e651ab83ce53451cc5034664">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_feldman_hash_set.html">cds::container::FeldmanHashSet</a>&lt; GC, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the element. </p>
<p>The operation performs inserting or replacing with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> will be inserted into the set iff <code>bInsert</code> is <code>true</code>. Otherwise, if <code>val</code> is found, it is replaced with new item created from <code>val</code> and previous item is disposed. In both cases <code>func</code> functor is called.</p>
<p>The functor <code>Func</code> signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a>&amp; cur, <a class="code" href="classcds_1_1container_1_1_feldman_hash_set.html#ac9e2fdcc6c4667962c5bf233493b19fe">value_type</a> * prev );</div><div class="line">};</div></div><!-- fragment --><p> where:</p><ul>
<li><code>cur</code> - current element</li>
<li><code>prev</code> - pointer to previous element with such hash. <code>prev</code> is <code>nullptr</code> if <code>cur</code> was just inserted.</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successful, i.e. the item has been inserted or updated, <code>second</code> is <code>true</code> if the new item has been added or <code>false</code> if the item with key equal to <code>val</code> already exists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/impl/feldman_hashset.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:47:00 by Doxygen 1.8.13</i>
</div>
</body>
</html>
