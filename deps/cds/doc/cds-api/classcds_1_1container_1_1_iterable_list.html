<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::IterableList&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_iterable_list.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::IterableList&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__list.html">List</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Iterable ordered list.  
 <a href="classcds_1_1container_1_1_iterable_list.html#details">More...</a></p>

<p><code>#include &lt;cds/container/impl/iterable_list.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::IterableList&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_iterable_list.png" usemap="#cds::container::IterableList_3C_20GC_2C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::IterableList_3C_20GC_2C_20T_2C_20Traits_20_3E_map" name="cds::container::IterableList_3C_20GC_2C_20T_2C_20Traits_20_3E_map">
<area href="classcds_1_1intrusive_1_1_iterable_list.html" title="Iterable lock-free ordered single-linked list. " alt="cds::intrusive::IterableList&lt; GC, T, Traits &gt;" shape="rect" coords="0,0,256,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7733909a3e21f724ed41d28aca5d4410"><td class="memItemLeft" align="right" valign="top"><a id="a7733909a3e21f724ed41d28aca5d4410"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a></td></tr>
<tr class="memdesc:a7733909a3e21f724ed41d28aca5d4410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of value stored in the list. <br /></td></tr>
<tr class="separator:a7733909a3e21f724ed41d28aca5d4410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbff5fcbf9cdf190e3ce4d0e450d7cb"><td class="memItemLeft" align="right" valign="top"><a id="a5fbff5fcbf9cdf190e3ce4d0e450d7cb"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a5fbff5fcbf9cdf190e3ce4d0e450d7cb">traits</a></td></tr>
<tr class="memdesc:a5fbff5fcbf9cdf190e3ce4d0e450d7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List traits. <br /></td></tr>
<tr class="separator:a5fbff5fcbf9cdf190e3ce4d0e450d7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081d78e252eff078f25e949911daf1df"><td class="memItemLeft" align="right" valign="top"><a id="a081d78e252eff078f25e949911daf1df"></a>
typedef base_class::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a081d78e252eff078f25e949911daf1df">gc</a></td></tr>
<tr class="memdesc:a081d78e252eff078f25e949911daf1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br /></td></tr>
<tr class="separator:a081d78e252eff078f25e949911daf1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace22a30dedbbc6fe51c3ec880cd18332"><td class="memItemLeft" align="right" valign="top"><a id="ace22a30dedbbc6fe51c3ec880cd18332"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ace22a30dedbbc6fe51c3ec880cd18332">back_off</a></td></tr>
<tr class="memdesc:ace22a30dedbbc6fe51c3ec880cd18332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy used. <br /></td></tr>
<tr class="separator:ace22a30dedbbc6fe51c3ec880cd18332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb3f6a214de19aa2f380ccc3dcc29f"><td class="memItemLeft" align="right" valign="top"><a id="a5eeb3f6a214de19aa2f380ccc3dcc29f"></a>
typedef maker::data_allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a5eeb3f6a214de19aa2f380ccc3dcc29f">allocator_type</a></td></tr>
<tr class="memdesc:a5eeb3f6a214de19aa2f380ccc3dcc29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate data. <br /></td></tr>
<tr class="separator:a5eeb3f6a214de19aa2f380ccc3dcc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804b3f2bd2a5ef10fd23c9dabcab4c02"><td class="memItemLeft" align="right" valign="top"><a id="a804b3f2bd2a5ef10fd23c9dabcab4c02"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a804b3f2bd2a5ef10fd23c9dabcab4c02">item_counter</a></td></tr>
<tr class="memdesc:a804b3f2bd2a5ef10fd23c9dabcab4c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a804b3f2bd2a5ef10fd23c9dabcab4c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccd2fadd673a1f3da1ccace434861c3"><td class="memItemLeft" align="right" valign="top"><a id="a3ccd2fadd673a1f3da1ccace434861c3"></a>
typedef maker::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a3ccd2fadd673a1f3da1ccace434861c3">key_comparator</a></td></tr>
<tr class="memdesc:a3ccd2fadd673a1f3da1ccace434861c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a3ccd2fadd673a1f3da1ccace434861c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e05e8b51dd790b9fc068eee2109c7c1"><td class="memItemLeft" align="right" valign="top"><a id="a7e05e8b51dd790b9fc068eee2109c7c1"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7e05e8b51dd790b9fc068eee2109c7c1">memory_model</a></td></tr>
<tr class="memdesc:a7e05e8b51dd790b9fc068eee2109c7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:a7e05e8b51dd790b9fc068eee2109c7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb72370216768aeafbab9cc717d8dbe"><td class="memItemLeft" align="right" valign="top"><a id="acdb72370216768aeafbab9cc717d8dbe"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#acdb72370216768aeafbab9cc717d8dbe">stat</a></td></tr>
<tr class="memdesc:acdb72370216768aeafbab9cc717d8dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:acdb72370216768aeafbab9cc717d8dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94a4707978184096fb47eb1dd7b961d"><td class="memItemLeft" align="right" valign="top"><a id="ae94a4707978184096fb47eb1dd7b961d"></a>
typedef base_class::guarded_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a></td></tr>
<tr class="memdesc:ae94a4707978184096fb47eb1dd7b961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:ae94a4707978184096fb47eb1dd7b961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9b5f31334e433d2d4abf6d09cca2e6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ad9b5f31334e433d2d4abf6d09cca2e6c">IterableList</a> ()</td></tr>
<tr class="memdesc:ad9b5f31334e433d2d4abf6d09cca2e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ad9b5f31334e433d2d4abf6d09cca2e6c">More...</a><br /></td></tr>
<tr class="separator:ad9b5f31334e433d2d4abf6d09cca2e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e78e4567a29a128c4feec11b5b947b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a4e78e4567a29a128c4feec11b5b947b5">~IterableList</a> ()</td></tr>
<tr class="memdesc:a4e78e4567a29a128c4feec11b5b947b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">List destructor.  <a href="#a4e78e4567a29a128c4feec11b5b947b5">More...</a><br /></td></tr>
<tr class="separator:a4e78e4567a29a128c4feec11b5b947b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd48d14e4734863673486bc567c8470"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a7cd48d14e4734863673486bc567c8470"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7cd48d14e4734863673486bc567c8470">insert</a> (Q &amp;&amp;val)</td></tr>
<tr class="memdesc:a7cd48d14e4734863673486bc567c8470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a7cd48d14e4734863673486bc567c8470">More...</a><br /></td></tr>
<tr class="separator:a7cd48d14e4734863673486bc567c8470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89349288779eef95ebe67eef7c575115"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a89349288779eef95ebe67eef7c575115"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a89349288779eef95ebe67eef7c575115">insert</a> (Q &amp;&amp;key, Func func)</td></tr>
<tr class="memdesc:a89349288779eef95ebe67eef7c575115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a89349288779eef95ebe67eef7c575115">More...</a><br /></td></tr>
<tr class="separator:a89349288779eef95ebe67eef7c575115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87956517d0ef236e14089a610de2a2e"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ab87956517d0ef236e14089a610de2a2e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab87956517d0ef236e14089a610de2a2e">update</a> (Q &amp;&amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ab87956517d0ef236e14089a610de2a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#ab87956517d0ef236e14089a610de2a2e">More...</a><br /></td></tr>
<tr class="separator:ab87956517d0ef236e14089a610de2a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df94589f93340291236d66ad0c28ee0"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a8df94589f93340291236d66ad0c28ee0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a8df94589f93340291236d66ad0c28ee0">upsert</a> (Q &amp;&amp;key, bool bInsert=true)</td></tr>
<tr class="memdesc:a8df94589f93340291236d66ad0c28ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update.  <a href="#a8df94589f93340291236d66ad0c28ee0">More...</a><br /></td></tr>
<tr class="separator:a8df94589f93340291236d66ad0c28ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e4bb8f4e886f4025212a1ff3452b9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae18e4bb8f4e886f4025212a1ff3452b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae18e4bb8f4e886f4025212a1ff3452b9">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae18e4bb8f4e886f4025212a1ff3452b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#ae18e4bb8f4e886f4025212a1ff3452b9">More...</a><br /></td></tr>
<tr class="separator:ae18e4bb8f4e886f4025212a1ff3452b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15af908e67d794e4c7eba45e5129359"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac15af908e67d794e4c7eba45e5129359"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ac15af908e67d794e4c7eba45e5129359">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ac15af908e67d794e4c7eba45e5129359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the list.  <a href="#ac15af908e67d794e4c7eba45e5129359">More...</a><br /></td></tr>
<tr class="separator:ac15af908e67d794e4c7eba45e5129359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721a3efc5db522818261b8c3e5775eab"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a721a3efc5db522818261b8c3e5775eab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a721a3efc5db522818261b8c3e5775eab">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a721a3efc5db522818261b8c3e5775eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a721a3efc5db522818261b8c3e5775eab">More...</a><br /></td></tr>
<tr class="separator:a721a3efc5db522818261b8c3e5775eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5be4765b1855158bad5789c14625513"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aa5be4765b1855158bad5789c14625513"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#aa5be4765b1855158bad5789c14625513">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:aa5be4765b1855158bad5789c14625513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the list.  <a href="#aa5be4765b1855158bad5789c14625513">More...</a><br /></td></tr>
<tr class="separator:aa5be4765b1855158bad5789c14625513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3875a58d5956b5d4ca107824921376"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aee3875a58d5956b5d4ca107824921376"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#aee3875a58d5956b5d4ca107824921376">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aee3875a58d5956b5d4ca107824921376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#aee3875a58d5956b5d4ca107824921376">More...</a><br /></td></tr>
<tr class="separator:aee3875a58d5956b5d4ca107824921376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4bd4b994ae0a6369b31ec7bf39be9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a6a4bd4b994ae0a6369b31ec7bf39be9f">erase_at</a> (<a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> const &amp;iter)</td></tr>
<tr class="memdesc:a6a4bd4b994ae0a6369b31ec7bf39be9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item pointed by iterator <code>iter</code>.  <a href="#a6a4bd4b994ae0a6369b31ec7bf39be9f">More...</a><br /></td></tr>
<tr class="separator:a6a4bd4b994ae0a6369b31ec7bf39be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7bef56175499f341e7b1028fa72eb6"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a7f7bef56175499f341e7b1028fa72eb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7f7bef56175499f341e7b1028fa72eb6">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a7f7bef56175499f341e7b1028fa72eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the list with specified <code>key</code>.  <a href="#a7f7bef56175499f341e7b1028fa72eb6">More...</a><br /></td></tr>
<tr class="separator:a7f7bef56175499f341e7b1028fa72eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa60be96cabc04c48171c3d07e41c09d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:aaa60be96cabc04c48171c3d07e41c09d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#aaa60be96cabc04c48171c3d07e41c09d">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aaa60be96cabc04c48171c3d07e41c09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the list with comparing functor <code>pred</code>.  <a href="#aaa60be96cabc04c48171c3d07e41c09d">More...</a><br /></td></tr>
<tr class="separator:aaa60be96cabc04c48171c3d07e41c09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5698ae6f2f54ad031fd5a0280895e5a6"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5698ae6f2f54ad031fd5a0280895e5a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a5698ae6f2f54ad031fd5a0280895e5a6">contains</a> (Q const &amp;key) const</td></tr>
<tr class="memdesc:a5698ae6f2f54ad031fd5a0280895e5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code>.  <a href="#a5698ae6f2f54ad031fd5a0280895e5a6">More...</a><br /></td></tr>
<tr class="separator:a5698ae6f2f54ad031fd5a0280895e5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909413f57fbcc5eb771d5e644234c825"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a909413f57fbcc5eb771d5e644234c825"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a909413f57fbcc5eb771d5e644234c825">contains</a> (Q const &amp;key, Less pred) const</td></tr>
<tr class="memdesc:a909413f57fbcc5eb771d5e644234c825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a909413f57fbcc5eb771d5e644234c825">More...</a><br /></td></tr>
<tr class="separator:a909413f57fbcc5eb771d5e644234c825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705c5526e107a4d1ee3f55186505eb35"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a705c5526e107a4d1ee3f55186505eb35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a705c5526e107a4d1ee3f55186505eb35">find</a> (Q &amp;key, Func f) const</td></tr>
<tr class="memdesc:a705c5526e107a4d1ee3f55186505eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and perform an action with it.  <a href="#a705c5526e107a4d1ee3f55186505eb35">More...</a><br /></td></tr>
<tr class="separator:a705c5526e107a4d1ee3f55186505eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a8237141aea8f12496817fede3f4ed"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:af2a8237141aea8f12496817fede3f4ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#af2a8237141aea8f12496817fede3f4ed">find</a> (Q const &amp;key) const</td></tr>
<tr class="memdesc:af2a8237141aea8f12496817fede3f4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in the list and returns iterator pointed to the item found.  <a href="#af2a8237141aea8f12496817fede3f4ed">More...</a><br /></td></tr>
<tr class="separator:af2a8237141aea8f12496817fede3f4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef04e9d60bbde2a08f372dce9a2290b"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aeef04e9d60bbde2a08f372dce9a2290b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#aeef04e9d60bbde2a08f372dce9a2290b">find_with</a> (Q &amp;key, Less pred, Func f) const</td></tr>
<tr class="memdesc:aeef04e9d60bbde2a08f372dce9a2290b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aeef04e9d60bbde2a08f372dce9a2290b">More...</a><br /></td></tr>
<tr class="separator:aeef04e9d60bbde2a08f372dce9a2290b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a4f16e77a7f343d6669909ba3ce79f"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a29a4f16e77a7f343d6669909ba3ce79f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a29a4f16e77a7f343d6669909ba3ce79f">find_with</a> (Q const &amp;key, Less pred) const</td></tr>
<tr class="memdesc:a29a4f16e77a7f343d6669909ba3ce79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in the list using <code>pred</code> predicate for searching and returns iterator pointed to the item found.  <a href="#a29a4f16e77a7f343d6669909ba3ce79f">More...</a><br /></td></tr>
<tr class="separator:a29a4f16e77a7f343d6669909ba3ce79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa90b55a86fab22212f9a01f2fa2f850"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:afa90b55a86fab22212f9a01f2fa2f850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#afa90b55a86fab22212f9a01f2fa2f850">get</a> (Q const &amp;key) const</td></tr>
<tr class="memdesc:afa90b55a86fab22212f9a01f2fa2f850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#afa90b55a86fab22212f9a01f2fa2f850">More...</a><br /></td></tr>
<tr class="separator:afa90b55a86fab22212f9a01f2fa2f850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6e5dbec87873d0b6c2b6288f516ae8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a4c6e5dbec87873d0b6c2b6288f516ae8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a4c6e5dbec87873d0b6c2b6288f516ae8">get_with</a> (Q const &amp;key, Less pred) const</td></tr>
<tr class="memdesc:a4c6e5dbec87873d0b6c2b6288f516ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a4c6e5dbec87873d0b6c2b6288f516ae8">More...</a><br /></td></tr>
<tr class="separator:a4c6e5dbec87873d0b6c2b6288f516ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d661ffca94077f17067c869ce9b150"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a64d661ffca94077f17067c869ce9b150">empty</a> () const</td></tr>
<tr class="memdesc:a64d661ffca94077f17067c869ce9b150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the list is empty.  <a href="#a64d661ffca94077f17067c869ce9b150">More...</a><br /></td></tr>
<tr class="separator:a64d661ffca94077f17067c869ce9b150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cfef4a5fecc3856a0a434e2b1467dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a64cfef4a5fecc3856a0a434e2b1467dc">size</a> () const</td></tr>
<tr class="memdesc:a64cfef4a5fecc3856a0a434e2b1467dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list's item count.  <a href="#a64cfef4a5fecc3856a0a434e2b1467dc">More...</a><br /></td></tr>
<tr class="separator:a64cfef4a5fecc3856a0a434e2b1467dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc261f4ed86ec5291e70cd040e85c0"><td class="memItemLeft" align="right" valign="top"><a id="a8bcc261f4ed86ec5291e70cd040e85c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a8bcc261f4ed86ec5291e70cd040e85c0">clear</a> ()</td></tr>
<tr class="memdesc:a8bcc261f4ed86ec5291e70cd040e85c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list (thread safe, not atomic) <br /></td></tr>
<tr class="separator:a8bcc261f4ed86ec5291e70cd040e85c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db43e4f60714bf76adda84675f5ed70"><td class="memItemLeft" align="right" valign="top"><a id="a9db43e4f60714bf76adda84675f5ed70"></a>
<a class="el" href="classcds_1_1container_1_1_iterable_list.html#acdb72370216768aeafbab9cc717d8dbe">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a9db43e4f60714bf76adda84675f5ed70">statistics</a> () const</td></tr>
<tr class="memdesc:a9db43e4f60714bf76adda84675f5ed70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a9db43e4f60714bf76adda84675f5ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae18bfdcb3c5092d2482bf24b15ea504e"><td class="memItemLeft" align="right" valign="top"><a id="ae18bfdcb3c5092d2482bf24b15ea504e"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae18bfdcb3c5092d2482bf24b15ea504e">c_nHazardPtrCount</a> = base_class::c_nHazardPtrCount</td></tr>
<tr class="memdesc:ae18bfdcb3c5092d2482bf24b15ea504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:ae18bfdcb3c5092d2482bf24b15ea504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread-safe forward iterators</h2></td></tr>
<tr class="memitem:abcc5b2737f7fe640ebb279b3b5493a8e"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a></td></tr>
<tr class="memdesc:abcc5b2737f7fe640ebb279b3b5493a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#abcc5b2737f7fe640ebb279b3b5493a8e">More...</a><br /></td></tr>
<tr class="separator:abcc5b2737f7fe640ebb279b3b5493a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3236c5b657f9df03f515a4c85db6174"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab3236c5b657f9df03f515a4c85db6174">const_iterator</a></td></tr>
<tr class="memdesc:ab3236c5b657f9df03f515a4c85db6174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="#ab3236c5b657f9df03f515a4c85db6174">More...</a><br /></td></tr>
<tr class="separator:ab3236c5b657f9df03f515a4c85db6174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58272a29ce341e5c4b9f93a422d52331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a58272a29ce341e5c4b9f93a422d52331">begin</a> ()</td></tr>
<tr class="memdesc:a58272a29ce341e5c4b9f93a422d52331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a list.  <a href="#a58272a29ce341e5c4b9f93a422d52331">More...</a><br /></td></tr>
<tr class="separator:a58272a29ce341e5c4b9f93a422d52331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a2b29ad6f7a259a7e4f6e2ab91ec7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a68a2b29ad6f7a259a7e4f6e2ab91ec7c">end</a> ()</td></tr>
<tr class="memdesc:a68a2b29ad6f7a259a7e4f6e2ab91ec7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a list.  <a href="#a68a2b29ad6f7a259a7e4f6e2ab91ec7c">More...</a><br /></td></tr>
<tr class="separator:a68a2b29ad6f7a259a7e4f6e2ab91ec7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b85e8f9436cc94fb56fbe8ed18e135"><td class="memItemLeft" align="right" valign="top"><a id="ad6b85e8f9436cc94fb56fbe8ed18e135"></a>
<a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab3236c5b657f9df03f515a4c85db6174">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ad6b85e8f9436cc94fb56fbe8ed18e135">begin</a> () const</td></tr>
<tr class="memdesc:ad6b85e8f9436cc94fb56fbe8ed18e135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:ad6b85e8f9436cc94fb56fbe8ed18e135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36311ff6afbc14deaefaa5acf738ba87"><td class="memItemLeft" align="right" valign="top"><a id="a36311ff6afbc14deaefaa5acf738ba87"></a>
<a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab3236c5b657f9df03f515a4c85db6174">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a36311ff6afbc14deaefaa5acf738ba87">cbegin</a> () const</td></tr>
<tr class="memdesc:a36311ff6afbc14deaefaa5acf738ba87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:a36311ff6afbc14deaefaa5acf738ba87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7183035acf8250c4e69c014ba54bdef3"><td class="memItemLeft" align="right" valign="top"><a id="a7183035acf8250c4e69c014ba54bdef3"></a>
<a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab3236c5b657f9df03f515a4c85db6174">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7183035acf8250c4e69c014ba54bdef3">end</a> () const</td></tr>
<tr class="memdesc:a7183035acf8250c4e69c014ba54bdef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:a7183035acf8250c4e69c014ba54bdef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af67ebc18f0e859b09894dc96b102b2"><td class="memItemLeft" align="right" valign="top"><a id="a7af67ebc18f0e859b09894dc96b102b2"></a>
<a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab3236c5b657f9df03f515a4c85db6174">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7af67ebc18f0e859b09894dc96b102b2">cend</a> () const</td></tr>
<tr class="memdesc:a7af67ebc18f0e859b09894dc96b102b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:a7af67ebc18f0e859b09894dc96b102b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_iterable_list"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_iterable_list')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html">cds::intrusive::IterableList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a2b0e4d3b80be127c82d7b0017673096e inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a2b0e4d3b80be127c82d7b0017673096e"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a></td></tr>
<tr class="memdesc:a2b0e4d3b80be127c82d7b0017673096e inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the list <br /></td></tr>
<tr class="separator:a2b0e4d3b80be127c82d7b0017673096e inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d9e335371a8af85ea1e8046cda4770 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a12d9e335371a8af85ea1e8046cda4770"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a12d9e335371a8af85ea1e8046cda4770">traits</a></td></tr>
<tr class="memdesc:a12d9e335371a8af85ea1e8046cda4770 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a12d9e335371a8af85ea1e8046cda4770 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4427397720405da8343f607aafc38a inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a6c4427397720405da8343f607aafc38a"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1iterable__list_1_1node.html">iterable_list::node</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a6c4427397720405da8343f607aafc38a">node_type</a></td></tr>
<tr class="memdesc:a6c4427397720405da8343f607aafc38a inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:a6c4427397720405da8343f607aafc38a inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598ac407b7799c80d1712bc47aae64e4 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a598ac407b7799c80d1712bc47aae64e4"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a598ac407b7799c80d1712bc47aae64e4">key_comparator</a></td></tr>
<tr class="memdesc:a598ac407b7799c80d1712bc47aae64e4 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br /></td></tr>
<tr class="separator:a598ac407b7799c80d1712bc47aae64e4 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f98e146e9c35f669fec869ef1753f2 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a15f98e146e9c35f669fec869ef1753f2"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a15f98e146e9c35f669fec869ef1753f2">disposer</a></td></tr>
<tr class="memdesc:a15f98e146e9c35f669fec869ef1753f2 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer for <code>value_type</code> <br /></td></tr>
<tr class="separator:a15f98e146e9c35f669fec869ef1753f2 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fb74deff87a07c2cfc0950f0562c65 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a59fb74deff87a07c2cfc0950f0562c65"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a59fb74deff87a07c2cfc0950f0562c65">gc</a></td></tr>
<tr class="memdesc:a59fb74deff87a07c2cfc0950f0562c65 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a59fb74deff87a07c2cfc0950f0562c65 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982e005fdc3fc1779c48cde030104268 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a982e005fdc3fc1779c48cde030104268"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a982e005fdc3fc1779c48cde030104268">back_off</a></td></tr>
<tr class="memdesc:a982e005fdc3fc1779c48cde030104268 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br /></td></tr>
<tr class="separator:a982e005fdc3fc1779c48cde030104268 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34686c29fa4993340b69f885f1aa3765 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a34686c29fa4993340b69f885f1aa3765"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a34686c29fa4993340b69f885f1aa3765">item_counter</a></td></tr>
<tr class="memdesc:a34686c29fa4993340b69f885f1aa3765 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a34686c29fa4993340b69f885f1aa3765 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af9a4d291a251a89bc64dbcd2d36f81 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a7af9a4d291a251a89bc64dbcd2d36f81"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a7af9a4d291a251a89bc64dbcd2d36f81">memory_model</a></td></tr>
<tr class="memdesc:a7af9a4d291a251a89bc64dbcd2d36f81 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:a7af9a4d291a251a89bc64dbcd2d36f81 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb013ea81f8761f6c1b536aae9d323e inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="adeb013ea81f8761f6c1b536aae9d323e"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#adeb013ea81f8761f6c1b536aae9d323e">node_allocator</a></td></tr>
<tr class="memdesc:adeb013ea81f8761f6c1b536aae9d323e inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator. <br /></td></tr>
<tr class="separator:adeb013ea81f8761f6c1b536aae9d323e inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83793f6f157a738baab3555d030df704 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a83793f6f157a738baab3555d030df704"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a83793f6f157a738baab3555d030df704">stat</a></td></tr>
<tr class="memdesc:a83793f6f157a738baab3555d030df704 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a83793f6f157a738baab3555d030df704 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e6b1eb2fde6f377cdf84ae285fdf51 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a31e6b1eb2fde6f377cdf84ae285fdf51"></a>
typedef gc::template <a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a31e6b1eb2fde6f377cdf84ae285fdf51">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a31e6b1eb2fde6f377cdf84ae285fdf51">guarded_ptr</a></td></tr>
<tr class="memdesc:a31e6b1eb2fde6f377cdf84ae285fdf51 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a31e6b1eb2fde6f377cdf84ae285fdf51 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141451efc38badc53632bf2a2fdaa382 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">iterator</a></td></tr>
<tr class="memdesc:a141451efc38badc53632bf2a2fdaa382 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">More...</a><br /></td></tr>
<tr class="separator:a141451efc38badc53632bf2a2fdaa382 inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae48bc2802ce90cdf9de0b651ac6fbc inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1ae48bc2802ce90cdf9de0b651ac6fbc">const_iterator</a></td></tr>
<tr class="memdesc:a1ae48bc2802ce90cdf9de0b651ac6fbc inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a1ae48bc2802ce90cdf9de0b651ac6fbc">More...</a><br /></td></tr>
<tr class="separator:a1ae48bc2802ce90cdf9de0b651ac6fbc inherit pro_types_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_iterable_list')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html">cds::intrusive::IterableList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:addeb7b50e96e602a09264924086fb889 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="addeb7b50e96e602a09264924086fb889"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#addeb7b50e96e602a09264924086fb889">IterableList</a> ()</td></tr>
<tr class="memdesc:addeb7b50e96e602a09264924086fb889 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes empty list. <br /></td></tr>
<tr class="separator:addeb7b50e96e602a09264924086fb889 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5034dd5fd8ce8607c633d7d09d5e34 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="afd5034dd5fd8ce8607c633d7d09d5e34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#afd5034dd5fd8ce8607c633d7d09d5e34">~IterableList</a> ()</td></tr>
<tr class="memdesc:afd5034dd5fd8ce8607c633d7d09d5e34 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list object. <br /></td></tr>
<tr class="separator:afd5034dd5fd8ce8607c633d7d09d5e34 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed44b5cd4c5111cee3ce4c104184ea85 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#aed44b5cd4c5111cee3ce4c104184ea85">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:aed44b5cd4c5111cee3ce4c104184ea85 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#aed44b5cd4c5111cee3ce4c104184ea85">More...</a><br /></td></tr>
<tr class="separator:aed44b5cd4c5111cee3ce4c104184ea85 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599ba61593be0e38c45dd0220ba6ab1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a4599ba61593be0e38c45dd0220ba6ab1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a4599ba61593be0e38c45dd0220ba6ab1">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a4599ba61593be0e38c45dd0220ba6ab1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a4599ba61593be0e38c45dd0220ba6ab1">More...</a><br /></td></tr>
<tr class="separator:a4599ba61593be0e38c45dd0220ba6ab1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca6624de2e43fb578b3e56057411af7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a7ca6624de2e43fb578b3e56057411af7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a7ca6624de2e43fb578b3e56057411af7">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &amp;val, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:a7ca6624de2e43fb578b3e56057411af7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a7ca6624de2e43fb578b3e56057411af7">More...</a><br /></td></tr>
<tr class="separator:a7ca6624de2e43fb578b3e56057411af7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e78e41e65e03a43c4a4294c92b57bc3 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a3e78e41e65e03a43c4a4294c92b57bc3">upsert</a> (<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &amp;val, bool bInsert=true)</td></tr>
<tr class="memdesc:a3e78e41e65e03a43c4a4294c92b57bc3 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a3e78e41e65e03a43c4a4294c92b57bc3">More...</a><br /></td></tr>
<tr class="separator:a3e78e41e65e03a43c4a4294c92b57bc3 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb6757b6661e1534aee25b5bc5e8b4 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2aeb6757b6661e1534aee25b5bc5e8b4">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a2b0e4d3b80be127c82d7b0017673096e">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a2aeb6757b6661e1534aee25b5bc5e8b4 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the list.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a2aeb6757b6661e1534aee25b5bc5e8b4">More...</a><br /></td></tr>
<tr class="separator:a2aeb6757b6661e1534aee25b5bc5e8b4 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17b4458d6b81b59541fef02648cb8a8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ae17b4458d6b81b59541fef02648cb8a8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#ae17b4458d6b81b59541fef02648cb8a8">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ae17b4458d6b81b59541fef02648cb8a8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#ae17b4458d6b81b59541fef02648cb8a8">More...</a><br /></td></tr>
<tr class="separator:ae17b4458d6b81b59541fef02648cb8a8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03004f2eea439f5ee76ab5804083cc8d inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a03004f2eea439f5ee76ab5804083cc8d inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a03004f2eea439f5ee76ab5804083cc8d">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a03004f2eea439f5ee76ab5804083cc8d inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a03004f2eea439f5ee76ab5804083cc8d">More...</a><br /></td></tr>
<tr class="separator:a03004f2eea439f5ee76ab5804083cc8d inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92df54ae0bd58751d71cc1d1f63548f8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a92df54ae0bd58751d71cc1d1f63548f8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a92df54ae0bd58751d71cc1d1f63548f8">erase</a> (Q const &amp;key, Func func)</td></tr>
<tr class="memdesc:a92df54ae0bd58751d71cc1d1f63548f8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a92df54ae0bd58751d71cc1d1f63548f8">More...</a><br /></td></tr>
<tr class="separator:a92df54ae0bd58751d71cc1d1f63548f8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbd32d730085d8f4e551f0567debb37 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:abdbd32d730085d8f4e551f0567debb37 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#abdbd32d730085d8f4e551f0567debb37">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:abdbd32d730085d8f4e551f0567debb37 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#abdbd32d730085d8f4e551f0567debb37">More...</a><br /></td></tr>
<tr class="separator:abdbd32d730085d8f4e551f0567debb37 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7145fe18fd2276bef6e215a7ea16fba1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a7145fe18fd2276bef6e215a7ea16fba1">erase_at</a> (<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">iterator</a> const &amp;iter)</td></tr>
<tr class="memdesc:a7145fe18fd2276bef6e215a7ea16fba1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item pointed by iterator <code>iter</code>.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a7145fe18fd2276bef6e215a7ea16fba1">More...</a><br /></td></tr>
<tr class="separator:a7145fe18fd2276bef6e215a7ea16fba1 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ef724f721b312184ce79f18db87d5 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:abb2ef724f721b312184ce79f18db87d5 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a31e6b1eb2fde6f377cdf84ae285fdf51">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#abb2ef724f721b312184ce79f18db87d5">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:abb2ef724f721b312184ce79f18db87d5 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the list with specified <code>key</code>.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#abb2ef724f721b312184ce79f18db87d5">More...</a><br /></td></tr>
<tr class="separator:abb2ef724f721b312184ce79f18db87d5 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c7b2fef90e3a48e32d49d0503ffe8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a184c7b2fef90e3a48e32d49d0503ffe8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a31e6b1eb2fde6f377cdf84ae285fdf51">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a184c7b2fef90e3a48e32d49d0503ffe8">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a184c7b2fef90e3a48e32d49d0503ffe8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a184c7b2fef90e3a48e32d49d0503ffe8">More...</a><br /></td></tr>
<tr class="separator:a184c7b2fef90e3a48e32d49d0503ffe8 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b10b7b4a91f4bfea1e5cd6f13bfbdf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a53b10b7b4a91f4bfea1e5cd6f13bfbdf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a53b10b7b4a91f4bfea1e5cd6f13bfbdf">find</a> (Q &amp;key, Func f) const</td></tr>
<tr class="memdesc:a53b10b7b4a91f4bfea1e5cd6f13bfbdf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in the list.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a53b10b7b4a91f4bfea1e5cd6f13bfbdf">More...</a><br /></td></tr>
<tr class="separator:a53b10b7b4a91f4bfea1e5cd6f13bfbdf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3318df602a6bbe7263e61c77cf201548 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a3318df602a6bbe7263e61c77cf201548 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a3318df602a6bbe7263e61c77cf201548">find</a> (Q const &amp;key) const</td></tr>
<tr class="memdesc:a3318df602a6bbe7263e61c77cf201548 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in the list and returns iterator pointed to the item found.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a3318df602a6bbe7263e61c77cf201548">More...</a><br /></td></tr>
<tr class="separator:a3318df602a6bbe7263e61c77cf201548 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecedc3fbeafd96c5a459abf617d3cd7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a8ecedc3fbeafd96c5a459abf617d3cd7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a8ecedc3fbeafd96c5a459abf617d3cd7">find_with</a> (Q &amp;key, Less pred, Func f) const</td></tr>
<tr class="memdesc:a8ecedc3fbeafd96c5a459abf617d3cd7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a8ecedc3fbeafd96c5a459abf617d3cd7">More...</a><br /></td></tr>
<tr class="separator:a8ecedc3fbeafd96c5a459abf617d3cd7 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea9b2c171a4d23c9ae9da9245e4f466 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a9ea9b2c171a4d23c9ae9da9245e4f466 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a9ea9b2c171a4d23c9ae9da9245e4f466">find_with</a> (Q const &amp;key, Less pred) const</td></tr>
<tr class="memdesc:a9ea9b2c171a4d23c9ae9da9245e4f466 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in the list using <code>pred</code> predicate for searching and returns iterator pointed to the item found.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a9ea9b2c171a4d23c9ae9da9245e4f466">More...</a><br /></td></tr>
<tr class="separator:a9ea9b2c171a4d23c9ae9da9245e4f466 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906902e1f16b5ad056bfa7917dd8ec07 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a906902e1f16b5ad056bfa7917dd8ec07 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a906902e1f16b5ad056bfa7917dd8ec07">contains</a> (Q const &amp;key) const</td></tr>
<tr class="memdesc:a906902e1f16b5ad056bfa7917dd8ec07 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a906902e1f16b5ad056bfa7917dd8ec07">More...</a><br /></td></tr>
<tr class="separator:a906902e1f16b5ad056bfa7917dd8ec07 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569e0b18840c7c07261a464a8573409c inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a569e0b18840c7c07261a464a8573409c inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a569e0b18840c7c07261a464a8573409c">contains</a> (Q const &amp;key, Less pred) const</td></tr>
<tr class="memdesc:a569e0b18840c7c07261a464a8573409c inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a569e0b18840c7c07261a464a8573409c">More...</a><br /></td></tr>
<tr class="separator:a569e0b18840c7c07261a464a8573409c inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9c8dcadda9597ccdfb92832e4c6733 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a7e9c8dcadda9597ccdfb92832e4c6733 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a31e6b1eb2fde6f377cdf84ae285fdf51">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a7e9c8dcadda9597ccdfb92832e4c6733">get</a> (Q const &amp;key) const</td></tr>
<tr class="memdesc:a7e9c8dcadda9597ccdfb92832e4c6733 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a7e9c8dcadda9597ccdfb92832e4c6733">More...</a><br /></td></tr>
<tr class="separator:a7e9c8dcadda9597ccdfb92832e4c6733 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9e9e65738228c1a37a886479b7b504 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a1b9e9e65738228c1a37a886479b7b504 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a31e6b1eb2fde6f377cdf84ae285fdf51">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1b9e9e65738228c1a37a886479b7b504">get_with</a> (Q const &amp;key, Less pred) const</td></tr>
<tr class="memdesc:a1b9e9e65738228c1a37a886479b7b504 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a1b9e9e65738228c1a37a886479b7b504">More...</a><br /></td></tr>
<tr class="separator:a1b9e9e65738228c1a37a886479b7b504 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbf6ba099da0f1f18398c028a75c2ac inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a1dbf6ba099da0f1f18398c028a75c2ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1dbf6ba099da0f1f18398c028a75c2ac">clear</a> ()</td></tr>
<tr class="memdesc:a1dbf6ba099da0f1f18398c028a75c2ac inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list (thread safe, not atomic) <br /></td></tr>
<tr class="separator:a1dbf6ba099da0f1f18398c028a75c2ac inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11502691253cf8b7846df0e9bd40d682 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a11502691253cf8b7846df0e9bd40d682">empty</a> () const</td></tr>
<tr class="memdesc:a11502691253cf8b7846df0e9bd40d682 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the list is empty.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a11502691253cf8b7846df0e9bd40d682">More...</a><br /></td></tr>
<tr class="separator:a11502691253cf8b7846df0e9bd40d682 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55d77d765d4f4a0166bc7d2a87f857a inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#ad55d77d765d4f4a0166bc7d2a87f857a">size</a> () const</td></tr>
<tr class="memdesc:ad55d77d765d4f4a0166bc7d2a87f857a inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list's item count.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#ad55d77d765d4f4a0166bc7d2a87f857a">More...</a><br /></td></tr>
<tr class="separator:ad55d77d765d4f4a0166bc7d2a87f857a inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8403d5d844ad1d449f6ed74c8faaddcf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a8403d5d844ad1d449f6ed74c8faaddcf"></a>
<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a83793f6f157a738baab3555d030df704">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a8403d5d844ad1d449f6ed74c8faaddcf">statistics</a> () const</td></tr>
<tr class="memdesc:a8403d5d844ad1d449f6ed74c8faaddcf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a8403d5d844ad1d449f6ed74c8faaddcf inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5f7724e23c40f0be14815357841939 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#adb5f7724e23c40f0be14815357841939">begin</a> ()</td></tr>
<tr class="memdesc:adb5f7724e23c40f0be14815357841939 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a list.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#adb5f7724e23c40f0be14815357841939">More...</a><br /></td></tr>
<tr class="separator:adb5f7724e23c40f0be14815357841939 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205278ce31de2e3aa7aa184364aed59b inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a141451efc38badc53632bf2a2fdaa382">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a205278ce31de2e3aa7aa184364aed59b">end</a> ()</td></tr>
<tr class="memdesc:a205278ce31de2e3aa7aa184364aed59b inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a list.  <a href="classcds_1_1intrusive_1_1_iterable_list.html#a205278ce31de2e3aa7aa184364aed59b">More...</a><br /></td></tr>
<tr class="separator:a205278ce31de2e3aa7aa184364aed59b inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf87e3445c8cbf5bfc944e25e4a735f inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="afbf87e3445c8cbf5bfc944e25e4a735f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1ae48bc2802ce90cdf9de0b651ac6fbc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#afbf87e3445c8cbf5bfc944e25e4a735f">cbegin</a> () const</td></tr>
<tr class="memdesc:afbf87e3445c8cbf5bfc944e25e4a735f inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:afbf87e3445c8cbf5bfc944e25e4a735f inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a5014010fc0b0ac2cec4aa1893e189 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a67a5014010fc0b0ac2cec4aa1893e189"></a>
<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1ae48bc2802ce90cdf9de0b651ac6fbc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a67a5014010fc0b0ac2cec4aa1893e189">begin</a> () const</td></tr>
<tr class="memdesc:a67a5014010fc0b0ac2cec4aa1893e189 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:a67a5014010fc0b0ac2cec4aa1893e189 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d08aee344fd87f97a12d6d20fe8aed9 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a7d08aee344fd87f97a12d6d20fe8aed9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1ae48bc2802ce90cdf9de0b651ac6fbc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a7d08aee344fd87f97a12d6d20fe8aed9">end</a> () const</td></tr>
<tr class="memdesc:a7d08aee344fd87f97a12d6d20fe8aed9 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:a7d08aee344fd87f97a12d6d20fe8aed9 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02da4f08f93bbcd0fd3211688ded93d3 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a02da4f08f93bbcd0fd3211688ded93d3"></a>
<a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a1ae48bc2802ce90cdf9de0b651ac6fbc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a02da4f08f93bbcd0fd3211688ded93d3">cend</a> () const</td></tr>
<tr class="memdesc:a02da4f08f93bbcd0fd3211688ded93d3 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:a02da4f08f93bbcd0fd3211688ded93d3 inherit pro_methods_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_iterable_list"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_iterable_list')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html">cds::intrusive::IterableList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a50ad4a02fa6b675faefb9500abc80e7c inherit pro_static_attribs_classcds_1_1intrusive_1_1_iterable_list"><td class="memItemLeft" align="right" valign="top"><a id="a50ad4a02fa6b675faefb9500abc80e7c"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_iterable_list.html#a50ad4a02fa6b675faefb9500abc80e7c">c_nHazardPtrCount</a> = 4</td></tr>
<tr class="memdesc:a50ad4a02fa6b675faefb9500abc80e7c inherit pro_static_attribs_classcds_1_1intrusive_1_1_iterable_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:a50ad4a02fa6b675faefb9500abc80e7c inherit pro_static_attribs_classcds_1_1intrusive_1_1_iterable_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt;<br />
class cds::container::IterableList&lt; GC, T, Traits &gt;</h3>

<p>Iterable ordered list. </p>
<p><a class="anchor" id="cds_nonintrusive_IterableList_gc"></a> This lock-free list implementation supports thread-safe iterators.</p>
<p>Usually, ordered single-linked list is used as a building block for the hash table implementation. Iterable list is suitable for almost append-only hash table because the list doesn't delete its internal node when erasing a key but it is marked them as empty to be reused in the future. However, plenty of empty nodes degrades performance.</p>
<p>The complexity of searching is <code>O(N)</code>.</p>
<p>Template arguments:</p><ul>
<li><code>GC</code> - Garbage collector used.</li>
<li><code>T</code> - type to be stored in the list.</li>
<li><code>Traits</code> - type traits, default is <code>iterable_list::traits</code>.</li>
</ul>
<p>Unlike standard container, this implementation does not divide type <code>T</code> into key and value part and may be used as a main building block for hash set algorithms. The key is a function (or a part) of type <code>T</code>, and this function is specified by <code>Traits::compare</code> functor or <code>Traits::less</code> predicate.</p>
<p><code><a class="el" href="classcds_1_1container_1_1_iterable_k_v_list.html" title="Iterable ordered list for key-value pair. ">IterableKVList</a></code> is a key-value version of iterable non-intrusive list that is closer to the C++ std library approach.</p>
<p>It is possible to declare option-based list with <a class="el" href="structcds_1_1container_1_1iterable__list_1_1make__traits.html">cds::container::iterable_list::make_traits</a> metafunction istead of <code>Traits</code> template argument. For example, the following traits-based declaration of <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer SMR (Safe Memory Reclamation) ">gc::HP</a> iterable list </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/iterable_list_hp.h&gt;</span></div><div class="line"><span class="comment">// Declare comparator for the item</span></div><div class="line"><span class="keyword">struct </span>my_compare {</div><div class="line">    <span class="keywordtype">int</span> operator ()( <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2 )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> i1 - i2;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare traits</span></div><div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> cds::container::iterable_list::traits</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> my_compare compare;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare traits-based list</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList&lt; cds::gc::HP, int, my_traits &gt;</a>     traits_based_list;</div></div><!-- fragment --><p>is equivalent for the following option-based list </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/iterable_list_hp.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// my_compare is the same</span></div><div class="line"></div><div class="line"><span class="comment">// Declare option-based list</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; cds::gc::HP, int,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1container_1_1iterable__list_1_1make__traits.html">cds::container::iterable_list::make_traits</a>&lt;</div><div class="line">        <a class="code" href="structcds_1_1opt_1_1compare.html">cds::container::opt::compare&lt; my_compare &gt;</a>     <span class="comment">// item comparator option</span></div><div class="line">    &gt;::type</div><div class="line">&gt; option_based_list;</div></div><!-- fragment --><dl class="section user"><dt>Usage</dt><dd>There are different specializations of this template for each garbage collecting schema used. You should include appropriate .h-file depending on GC you are using:<ul>
<li>for <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer SMR (Safe Memory Reclamation) ">gc::HP</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/iterable_list_hp.h&gt;</span> </div></div><!-- fragment --></li>
<li>for <a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic (adaptie) Hazard Pointer SMR. ">gc::DHP</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/iterable_list_dhp.h&gt;</span> </div></div><!-- fragment --></li>
<li>for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/iterable_list_rcu.h&gt;</span> </div></div><!-- fragment --> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab3236c5b657f9df03f515a4c85db6174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3236c5b657f9df03f515a4c85db6174">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;true&gt; <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_iterable_list.html#ab3236c5b657f9df03f515a4c85db6174">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const forward iterator. </p>
<p>For iterator's features and requirements see <a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> </p>

</div>
</div>
<a id="abcc5b2737f7fe640ebb279b3b5493a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc5b2737f7fe640ebb279b3b5493a8e">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;false&gt; <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward iterator. </p>
<p>The forward iterator for iterable list has some features:</p><ul>
<li>it has no post-increment operator</li>
<li>to protect the value, the iterator contains a GC-specific guard. For some GC (like as <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer SMR (Safe Memory Reclamation) ">gc::HP</a></code>), a guard is a limited resource per thread, so an exception (or assertion) "no free guard" may be thrown if the limit of guard count per thread is exceeded.</li>
<li>The iterator cannot be moved across thread boundary since it contains thread-private GC's guard.</li>
<li>Iterator is thread-safe: even if an element the iterator points to is removed, the iterator stays valid because it contains the guard keeping the value from to be recycled.</li>
</ul>
<p>The iterator interface: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Default constructor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy constructor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>( <a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <span class="keyword">const</span>&amp; src );</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Preincrement operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Assignment operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a>&amp; operator = (<a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <span class="keyword">const</span>&amp; src);</div><div class="line"></div><div class="line">    <span class="comment">// Equality operators</span></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For two iterators pointed to the same element the value can be different; this code <div class="fragment"><div class="line"><span class="keywordflow">if</span> ( it1 == it2 )</div><div class="line">    assert( &amp;(*it1) == &amp;(*it2));</div></div><!-- fragment --> can throw assertion. The point is that the iterator stores the value of element which can be modified later by other thread. The guard inside the iterator prevents recycling that value so the iterator's value remains valid even after such changing. Other iterator can observe modified value of the element. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad9b5f31334e433d2d4abf6d09cca2e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b5f31334e433d2d4abf6d09cca2e6c">&#9670;&nbsp;</a></span>IterableList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_iterable_list.html">IterableList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initialize empty list </p>

</div>
</div>
<a id="a4e78e4567a29a128c4feec11b5b947b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e78e4567a29a128c4feec11b5b947b5">&#9670;&nbsp;</a></span>~IterableList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::~<a class="el" href="classcds_1_1container_1_1_iterable_list.html">IterableList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List destructor. </p>
<p>Clears the list </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a58272a29ce341e5c4b9f93a422d52331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58272a29ce341e5c4b9f93a422d52331">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a list. </p>
<p>For empty list</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_iterable_list.html#a58272a29ce341e5c4b9f93a422d52331">begin</a>() == <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a68a2b29ad6f7a259a7e4f6e2ab91ec7c">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="a5698ae6f2f54ad031fd5a0280895e5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5698ae6f2f54ad031fd5a0280895e5a6">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the list contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a909413f57fbcc5eb771d5e644234c825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909413f57fbcc5eb771d5e644234c825">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the list contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="ae18e4bb8f4e886f4025212a1ff3452b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18e4bb8f4e886f4025212a1ff3452b9">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a64d661ffca94077f17067c869ce9b150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d661ffca94077f17067c869ce9b150">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the list is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. Thus, if you need to use <code>empty</code>() you should provide appropriate (non-empty) <code>iterable_list::traits::item_counter</code> feature. </p>

</div>
</div>
<a id="a68a2b29ad6f7a259a7e4f6e2ab91ec7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a2b29ad6f7a259a7e4f6e2ab91ec7c">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a list. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. Internally, <code>end</code> returning value equals to <code>nullptr</code>.</p>
<p>The returned value can be used only to control reaching the end of the list. For empty list</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_iterable_list.html#a58272a29ce341e5c4b9f93a422d52331">begin</a>() == <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a68a2b29ad6f7a259a7e4f6e2ab91ec7c">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="ac15af908e67d794e4c7eba45e5129359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15af908e67d794e4c7eba45e5129359">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the list. </p>
<p>Since the key of <a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a>'s item type <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> sould contain the complete key to search in the list. The list item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="aa5be4765b1855158bad5789c14625513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5be4765b1855158bad5789c14625513">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the list. </p>
<p>The function searches an item with key <code>key</code>, calls <code>f</code> functor with item found and deletes it. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a>&amp; val) { ... }</div><div class="line">};</div></div><!-- fragment --><p>Since the key of <a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a>'s item type <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> should contain the complete key to search in the list. The list item comparator should be able to compare the type <code>value_type</code> of list item and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a6a4bd4b994ae0a6369b31ec7bf39be9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4bd4b994ae0a6369b31ec7bf39be9f">&#9670;&nbsp;</a></span>erase_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::erase_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> const &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item pointed by iterator <code>iter</code>. </p>
<p>Returns <code>true</code> if the operation is successful, <code>false</code> otherwise. The function can return <code>false</code> if the node the iterator points to has already been deleted by other thread.</p>
<p>The function does not invalidate the iterator, it remains valid and can be used for further traversing. </p>

</div>
</div>
<a id="a721a3efc5db522818261b8c3e5775eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721a3efc5db522818261b8c3e5775eab">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ac15af908e67d794e4c7eba45e5129359" title="Delete key from the list. ">erase(Q const&amp;)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="aee3875a58d5956b5d4ca107824921376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3875a58d5956b5d4ca107824921376">&#9670;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html#aa5be4765b1855158bad5789c14625513" title="Deletes key from the list. ">erase(Q const&amp;, Func)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a7f7bef56175499f341e7b1028fa72eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7bef56175499f341e7b1028fa72eb6">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the list with specified <code>key</code>. </p>
<p>The function searches an item with key equal to <code>key</code>, unlinks it from the list, and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>Note the compare functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList&lt; cds::gc::HP, foo, my_traits &gt;</a>  ord_list;</div><div class="line">ord_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    ord_list::guarded_ptr gp(theList.extract( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and frees the item</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="aaa60be96cabc04c48171c3d07e41c09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa60be96cabc04c48171c3d07e41c09d">&#9670;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the list with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7f7bef56175499f341e7b1028fa72eb6" title="Extracts the item from the list with specified key. ">extract(Q const&amp;)</a></code> but <code>pred</code> predicate is used for key comparing.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but it should accept arguments of type <code>value_type</code> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a705c5526e107a4d1ee3f55186505eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705c5526e107a4d1ee3f55186505eb35">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and perform an action with it. </p>
<p>The function searches an item with key equal to <code>key</code> and calls the functor <code>f</code> for the item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a>&amp; item, Q&amp; key );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the function is only guarantee that <code>item</code> cannot be deleted during functor is executing. The function does not serialize simultaneous access to the list <code>item</code>. If such access is possible you must provide your own synchronization schema to exclude unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="af2a8237141aea8f12496817fede3f4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a8237141aea8f12496817fede3f4ed">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> in the list and returns iterator pointed to the item found. </p>
<p>If <code>key</code> is not found the function returns <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a68a2b29ad6f7a259a7e4f6e2ab91ec7c" title="Returns an iterator that addresses the location succeeding the last element in a list. ">end()</a></code>. </p>

</div>
</div>
<a id="aeef04e9d60bbde2a08f372dce9a2290b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef04e9d60bbde2a08f372dce9a2290b">&#9670;&nbsp;</a></span>find_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>find(Q&amp;, Func)</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a29a4f16e77a7f343d6669909ba3ce79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a4f16e77a7f343d6669909ba3ce79f">&#9670;&nbsp;</a></span>find_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#abcc5b2737f7fe640ebb279b3b5493a8e">iterator</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> in the list using <code>pred</code> predicate for searching and returns iterator pointed to the item found. </p>
<p>The function is an analog of <code>find(Q&amp;)</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list.</p>
<p>If <code>key</code> is not found the function returns <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html#a68a2b29ad6f7a259a7e4f6e2ab91ec7c" title="Returns an iterator that addresses the location succeeding the last element in a list. ">end()</a></code>. </p>

</div>
</div>
<a id="afa90b55a86fab22212f9a01f2fa2f850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa90b55a86fab22212f9a01f2fa2f850">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelList_hp_get"></a>The function searches the item with key equal to <code>key</code> and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList&lt; cds::gc::HP, foo, my_traits &gt;</a>  ord_list;</div><div class="line">ord_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    ord_list::guarded_ptr gp(theList.get( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard and frees the item</span></div><div class="line">}</div></div><!-- fragment --><p>Note the compare functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a id="a4c6e5dbec87873d0b6c2b6288f516ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6e5dbec87873d0b6c2b6288f516ae8">&#9670;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_iterable_list.html#ae94a4707978184096fb47eb1dd7b961d">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_iterable_list.html#cds_nonintrusive_MichaelList_hp_get">get( Q const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should accept arguments of type <code>value_type</code> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a7cd48d14e4734863673486bc567c8470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd48d14e4734863673486bc567c8470">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the list.</p>
<p>The type <code>Q</code> should contain least the complete key of the node. The object of <a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a> should be constructible from <code>val</code> of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a>.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a89349288779eef95ebe67eef7c575115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89349288779eef95ebe67eef7c575115">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>This function inserts new node with default-constructed value and then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a>&amp; data );</div></div><!-- fragment --><p>The argument <code>data</code> of user-defined functor <code>func</code> is the reference to the list's item inserted. User-defined functor <code>func</code> should guarantee that during changing item's value no any other changes could be made on this list's item by concurrent threads. The user-defined functor is called only if inserting is success.</p>
<p>The type <code>Q</code> should contain the complete key of the node. The object of <code>value_type</code> should be constructible from <code>key</code> of type <code>Q</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code> with initializing key-fields only;</li>
<li>insert new item into the list;</li>
<li>if inserting is successful, initialize non-key fields of item by calling <code>func</code> functor</li>
</ul>
<p>The method can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<a id="a64cfef4a5fecc3856a0a434e2b1467dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cfef4a5fecc3856a0a434e2b1467dc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns list's item count. </p>
<p>The value returned depends on item counter provided by <code>Traits</code>. For <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code>, this function always returns 0. </p>

</div>
</div>
<a id="ab87956517d0ef236e14089a610de2a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87956517d0ef236e14089a610de2a2e">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or replacing the element with lock-free manner.</p>
<p>If the <code>key</code> not found in the list, then the new item created from <code>key</code> will be inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found.</p>
<p>The functor <code>func</code> is called after inserting or replacing, it signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a>&amp; val, <a class="code" href="classcds_1_1container_1_1_iterable_list.html#a7733909a3e21f724ed41d28aca5d4410">value_type</a> * old );</div></div><!-- fragment --><p> where</p><ul>
<li><code>val</code> - a new data constructed from <code>key</code> </li>
<li><code>old</code> - old value that will be retired. If new item has been inserted then <code>old</code> is <code>nullptr</code>.</li>
</ul>
<p>The functor may change non-key fields of <code>val</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with such <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<a id="a8df94589f93340291236d66ad0c28ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df94589f93340291236d66ad0c28ee0">&#9670;&nbsp;</a></span>upsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = iterable_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_iterable_list.html">cds::container::IterableList</a>&lt; GC, T, Traits &gt;::upsert </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or update. </p>
<p>The operation performs inserting or updating data with lock-free manner.</p>
<p>If the item <code>key</code> is not found in the list, then <code>key</code> is inserted iff <code>bInsert</code> is <code>true</code>. Otherwise, the current element is changed to <code>key</code>, the old element will be retired later.</p>
<p><code>value_type</code> should be constructible from <code>key</code>.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successful, <code>second</code> is <code>true</code> if <code>key</code> has been added or <code>false</code> if the item with that key already in the list. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cds/container/details/iterable_list_base.h</li>
<li>cds/container/impl/iterable_list.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:47:00 by Doxygen 1.8.13</i>
</div>
</body>
</html>
